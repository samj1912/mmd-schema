#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Jun  6 14:50:50 2017 by generateDS.py version 2.26a.
#
# Command line options:
#   ('-o', 'mbrng/models.py')
#   ('-s', 'mbrng/mb_mmd_subs.py')
#   ('--super', 'mb')
#   ('--external-encoding', 'utf-8')
#   ('--export', 'write etree')
#
# Command line arguments:
#   musicbrainz_mmd.xsd
#
# Command line:
#   /usr/bin/generateDS.py -o "mbrng/models.py" -s "mbrng/mb_mmd_subs.py" --super="mb" --external-encoding="utf-8" --export="write etree" musicbrainz_mmd.xsd
#
# Current working directory (os.getcwd()):
#   mb-rngpy
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name, pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0, optional=0):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class def_area_element_inner(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, sort_name=None, disambiguation=None, iso_3166_1_code_list=None, iso_3166_2_code_list=None, iso_3166_3_code_list=None, annotation=None, life_span=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.name = name
        self.sort_name = sort_name
        self.disambiguation = disambiguation
        self.iso_3166_1_code_list = iso_3166_1_code_list
        self.iso_3166_2_code_list = iso_3166_2_code_list
        self.iso_3166_3_code_list = iso_3166_3_code_list
        self.annotation = annotation
        self.life_span = life_span
        self.alias_list = alias_list
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.tag_list = tag_list
        self.user_tag_list = user_tag_list
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_area_element_inner)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_area_element_inner.subclass:
            return def_area_element_inner.subclass(*args_, **kwargs_)
        else:
            return def_area_element_inner(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_sort_name(self): return self.sort_name
    def set_sort_name(self, sort_name): self.sort_name = sort_name
    def get_disambiguation(self): return self.disambiguation
    def set_disambiguation(self, disambiguation): self.disambiguation = disambiguation
    def get_iso_3166_1_code_list(self): return self.iso_3166_1_code_list
    def set_iso_3166_1_code_list(self, iso_3166_1_code_list): self.iso_3166_1_code_list = iso_3166_1_code_list
    def get_iso_3166_2_code_list(self): return self.iso_3166_2_code_list
    def set_iso_3166_2_code_list(self, iso_3166_2_code_list): self.iso_3166_2_code_list = iso_3166_2_code_list
    def get_iso_3166_3_code_list(self): return self.iso_3166_3_code_list
    def set_iso_3166_3_code_list(self, iso_3166_3_code_list): self.iso_3166_3_code_list = iso_3166_3_code_list
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def get_life_span(self): return self.life_span
    def set_life_span(self, life_span): self.life_span = life_span
    def get_alias_list(self): return self.alias_list
    def set_alias_list(self, alias_list): self.alias_list = alias_list
    def get_relation_list(self): return self.relation_list
    def set_relation_list(self, relation_list): self.relation_list = relation_list
    def add_relation_list(self, value): self.relation_list.append(value)
    def insert_relation_list_at(self, index, value): self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value): self.relation_list[index] = value
    def get_tag_list(self): return self.tag_list
    def set_tag_list(self, tag_list): self.tag_list = tag_list
    def get_user_tag_list(self): return self.user_tag_list
    def set_user_tag_list(self, user_tag_list): self.user_tag_list = user_tag_list
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def hasContent_(self):
        if (
            self.name is not None or
            self.sort_name is not None or
            self.disambiguation is not None or
            self.iso_3166_1_code_list is not None or
            self.iso_3166_2_code_list is not None or
            self.iso_3166_3_code_list is not None or
            self.annotation is not None or
            self.life_span is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='def_area-element_inner', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='def_area-element_inner')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='def_area-element_inner', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='def_area-element_inner'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='def_area-element_inner', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.sort_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssort-name>%s</%ssort-name>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.sort_name), input_name='sort-name')), namespace_, eol_))
        if self.disambiguation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespace_, eol_))
        if self.iso_3166_1_code_list is not None:
            self.iso_3166_1_code_list.export(outfile, level, namespace_='mmd-2.0:', name_='iso-3166-1-code-list', pretty_print=pretty_print)
        if self.iso_3166_2_code_list is not None:
            self.iso_3166_2_code_list.export(outfile, level, namespace_='mmd-2.0:', name_='iso-3166-2-code-list', pretty_print=pretty_print)
        if self.iso_3166_3_code_list is not None:
            self.iso_3166_3_code_list.export(outfile, level, namespace_='mmd-2.0:', name_='iso-3166-3-code-list', pretty_print=pretty_print)
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_='mmd-2.0:', name_='annotation', pretty_print=pretty_print)
        if self.life_span is not None:
            self.life_span.export(outfile, level, namespace_='mmd-2.0:', name_='life-span', pretty_print=pretty_print)
        if self.alias_list is not None:
            self.alias_list.export(outfile, level, namespace_='mmd-2.0:', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            relation_list_.export(outfile, level, namespace_='mmd-2.0:', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            self.tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            self.user_tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='user-tag-list', pretty_print=pretty_print)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='def_area-element_inner', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.sort_name is not None:
            sort_name_ = self.sort_name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}sort-name').text = self.gds_format_string(sort_name_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.iso_3166_1_code_list is not None:
            iso_3166_1_code_list_ = self.iso_3166_1_code_list
            iso_3166_1_code_list_.to_etree(element, name_='iso-3166-1-code-list', mapping_=mapping_)
        if self.iso_3166_2_code_list is not None:
            iso_3166_2_code_list_ = self.iso_3166_2_code_list
            iso_3166_2_code_list_.to_etree(element, name_='iso-3166-2-code-list', mapping_=mapping_)
        if self.iso_3166_3_code_list is not None:
            iso_3166_3_code_list_ = self.iso_3166_3_code_list
            iso_3166_3_code_list_.to_etree(element, name_='iso-3166-3-code-list', mapping_=mapping_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_)
        if self.life_span is not None:
            life_span_ = self.life_span
            life_span_.to_etree(element, name_='life-span', mapping_=mapping_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_)
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.to_etree(element)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'sort-name':
            sort_name_ = child_.text
            sort_name_ = self.gds_validate_string(sort_name_, node, 'sort_name')
            self.sort_name = sort_name_
        elif nodeName_ == 'disambiguation':
            disambiguation_ = child_.text
            disambiguation_ = self.gds_validate_string(disambiguation_, node, 'disambiguation')
            self.disambiguation = disambiguation_
        elif nodeName_ == 'iso-3166-1-code-list':
            obj_ = iso_3166_1_code_list.factory()
            obj_.build(child_)
            self.iso_3166_1_code_list = obj_
            obj_.original_tagname_ = 'iso-3166-1-code-list'
        elif nodeName_ == 'iso-3166-2-code-list':
            obj_ = iso_3166_2_code_list.factory()
            obj_.build(child_)
            self.iso_3166_2_code_list = obj_
            obj_.original_tagname_ = 'iso-3166-2-code-list'
        elif nodeName_ == 'iso-3166-3-code-list':
            obj_ = iso_3166_3_code_list.factory()
            obj_.build(child_)
            self.iso_3166_3_code_list = obj_
            obj_.original_tagname_ = 'iso-3166-3-code-list'
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory()
            obj_.build(child_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'life-span':
            obj_ = life_span.factory()
            obj_.build(child_)
            self.life_span = obj_
            obj_.original_tagname_ = 'life-span'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory()
            obj_.build(child_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory()
            obj_.build(child_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory()
            obj_.build(child_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory()
            obj_.build(child_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        else:
            obj_ = self.gds_build_any(child_, 'def_area-element_inner')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class def_area_element_inner


class def_track_data(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, position=None, number=None, title=None, length=None, artist_credit=None, recording=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.position = position
        self.number = number
        self.title = title
        self.length = length
        self.artist_credit = artist_credit
        self.recording = recording
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, def_track_data)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if def_track_data.subclass:
            return def_track_data.subclass(*args_, **kwargs_)
        else:
            return def_track_data(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_artist_credit(self): return self.artist_credit
    def set_artist_credit(self, artist_credit): self.artist_credit = artist_credit
    def get_recording(self): return self.recording
    def set_recording(self, recording): self.recording = recording
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.position is not None or
            self.number is not None or
            self.title is not None or
            self.length is not None or
            self.artist_credit is not None or
            self.recording is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='def_track-data', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='def_track-data')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='def_track-data', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='def_track-data'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='def_track-data', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.position is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sposition>%s</%sposition>%s' % (namespace_, self.gds_format_integer(self.position, input_name='position'), namespace_, eol_))
        if self.number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumber>%s</%snumber>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.number), input_name='number')), namespace_, eol_))
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespace_, eol_))
        if self.length is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespace_, self.gds_format_integer(self.length, input_name='length'), namespace_, eol_))
        if self.artist_credit is not None:
            self.artist_credit.export(outfile, level, namespace_='mmd-2.0:', name_='artist-credit', pretty_print=pretty_print)
        if self.recording is not None:
            self.recording.export(outfile, level, namespace_='mmd-2.0:', name_='recording', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='def_track-data', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.position is not None:
            position_ = self.position
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}position').text = self.gds_format_integer(position_)
        if self.number is not None:
            number_ = self.number
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}number').text = self.gds_format_string(number_)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}length').text = self.gds_format_integer(length_)
        if self.artist_credit is not None:
            artist_credit_ = self.artist_credit
            artist_credit_.to_etree(element, name_='artist-credit', mapping_=mapping_)
        if self.recording is not None:
            recording_ = self.recording
            recording_.to_etree(element, name_='recording', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'position':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'position')
            self.position = ival_
        elif nodeName_ == 'number':
            number_ = child_.text
            number_ = self.gds_validate_string(number_, node, 'number')
            self.number = number_
        elif nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'length':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
        elif nodeName_ == 'artist-credit':
            obj_ = artist_credit.factory()
            obj_.build(child_)
            self.artist_credit = obj_
            obj_.original_tagname_ = 'artist-credit'
        elif nodeName_ == 'recording':
            obj_ = recording.factory()
            obj_.build(child_)
            self.recording = obj_
            obj_.original_tagname_ = 'recording'
# end class def_track_data


class metadata(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, generator=None, created=None, artist=None, release=None, release_group=None, recording=None, label=None, work=None, area=None, place=None, instrument=None, series=None, event=None, url=None, puid=None, isrc=None, disc=None, rating=None, user_rating=None, collection=None, editor=None, artist_list=None, release_list=None, release_group_list=None, recording_list=None, label_list=None, work_list=None, area_list=None, place_list=None, instrument_list=None, series_list=None, event_list=None, url_list=None, isrc_list=None, annotation_list=None, cdstub_list=None, freedb_disc_list=None, tag_list=None, user_tag_list=None, collection_list=None, editor_list=None, entity_list=None, def_extension_element=None):
        self.original_tagname_ = None
        self.generator = _cast(None, generator)
        if isinstance(created, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(created, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = created
        self.created = initvalue_
        self.artist = artist
        self.release = release
        self.release_group = release_group
        self.recording = recording
        self.label = label
        self.work = work
        self.area = area
        self.place = place
        self.instrument = instrument
        self.series = series
        self.event = event
        self.url = url
        self.puid = puid
        self.isrc = isrc
        self.disc = disc
        self.rating = rating
        self.user_rating = user_rating
        self.collection = collection
        self.editor = editor
        self.artist_list = artist_list
        self.release_list = release_list
        self.release_group_list = release_group_list
        self.recording_list = recording_list
        self.label_list = label_list
        self.work_list = work_list
        self.area_list = area_list
        self.place_list = place_list
        self.instrument_list = instrument_list
        self.series_list = series_list
        self.event_list = event_list
        self.url_list = url_list
        self.isrc_list = isrc_list
        self.annotation_list = annotation_list
        self.cdstub_list = cdstub_list
        self.freedb_disc_list = freedb_disc_list
        self.tag_list = tag_list
        self.user_tag_list = user_tag_list
        self.collection_list = collection_list
        self.editor_list = editor_list
        self.entity_list = entity_list
        self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, metadata)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if metadata.subclass:
            return metadata.subclass(*args_, **kwargs_)
        else:
            return metadata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_artist(self): return self.artist
    def set_artist(self, artist): self.artist = artist
    def get_release(self): return self.release
    def set_release(self, release): self.release = release
    def get_release_group(self): return self.release_group
    def set_release_group(self, release_group): self.release_group = release_group
    def get_recording(self): return self.recording
    def set_recording(self, recording): self.recording = recording
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_work(self): return self.work
    def set_work(self, work): self.work = work
    def get_area(self): return self.area
    def set_area(self, area): self.area = area
    def get_place(self): return self.place
    def set_place(self, place): self.place = place
    def get_instrument(self): return self.instrument
    def set_instrument(self, instrument): self.instrument = instrument
    def get_series(self): return self.series
    def set_series(self, series): self.series = series
    def get_event(self): return self.event
    def set_event(self, event): self.event = event
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_puid(self): return self.puid
    def set_puid(self, puid): self.puid = puid
    def get_isrc(self): return self.isrc
    def set_isrc(self, isrc): self.isrc = isrc
    def get_disc(self): return self.disc
    def set_disc(self, disc): self.disc = disc
    def get_rating(self): return self.rating
    def set_rating(self, rating): self.rating = rating
    def get_user_rating(self): return self.user_rating
    def set_user_rating(self, user_rating): self.user_rating = user_rating
    def get_collection(self): return self.collection
    def set_collection(self, collection): self.collection = collection
    def get_editor(self): return self.editor
    def set_editor(self, editor): self.editor = editor
    def get_artist_list(self): return self.artist_list
    def set_artist_list(self, artist_list): self.artist_list = artist_list
    def get_release_list(self): return self.release_list
    def set_release_list(self, release_list): self.release_list = release_list
    def get_release_group_list(self): return self.release_group_list
    def set_release_group_list(self, release_group_list): self.release_group_list = release_group_list
    def get_recording_list(self): return self.recording_list
    def set_recording_list(self, recording_list): self.recording_list = recording_list
    def get_label_list(self): return self.label_list
    def set_label_list(self, label_list): self.label_list = label_list
    def get_work_list(self): return self.work_list
    def set_work_list(self, work_list): self.work_list = work_list
    def get_area_list(self): return self.area_list
    def set_area_list(self, area_list): self.area_list = area_list
    def get_place_list(self): return self.place_list
    def set_place_list(self, place_list): self.place_list = place_list
    def get_instrument_list(self): return self.instrument_list
    def set_instrument_list(self, instrument_list): self.instrument_list = instrument_list
    def get_series_list(self): return self.series_list
    def set_series_list(self, series_list): self.series_list = series_list
    def get_event_list(self): return self.event_list
    def set_event_list(self, event_list): self.event_list = event_list
    def get_url_list(self): return self.url_list
    def set_url_list(self, url_list): self.url_list = url_list
    def get_isrc_list(self): return self.isrc_list
    def set_isrc_list(self, isrc_list): self.isrc_list = isrc_list
    def get_annotation_list(self): return self.annotation_list
    def set_annotation_list(self, annotation_list): self.annotation_list = annotation_list
    def get_cdstub_list(self): return self.cdstub_list
    def set_cdstub_list(self, cdstub_list): self.cdstub_list = cdstub_list
    def get_freedb_disc_list(self): return self.freedb_disc_list
    def set_freedb_disc_list(self, freedb_disc_list): self.freedb_disc_list = freedb_disc_list
    def get_tag_list(self): return self.tag_list
    def set_tag_list(self, tag_list): self.tag_list = tag_list
    def get_user_tag_list(self): return self.user_tag_list
    def set_user_tag_list(self, user_tag_list): self.user_tag_list = user_tag_list
    def get_collection_list(self): return self.collection_list
    def set_collection_list(self, collection_list): self.collection_list = collection_list
    def get_editor_list(self): return self.editor_list
    def set_editor_list(self, editor_list): self.editor_list = editor_list
    def get_entity_list(self): return self.entity_list
    def set_entity_list(self, entity_list): self.entity_list = entity_list
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def get_generator(self): return self.generator
    def set_generator(self, generator): self.generator = generator
    def get_created(self): return self.created
    def set_created(self, created): self.created = created
    def hasContent_(self):
        if (
            self.artist is not None or
            self.release is not None or
            self.release_group is not None or
            self.recording is not None or
            self.label is not None or
            self.work is not None or
            self.area is not None or
            self.place is not None or
            self.instrument is not None or
            self.series is not None or
            self.event is not None or
            self.url is not None or
            self.puid is not None or
            self.isrc is not None or
            self.disc is not None or
            self.rating is not None or
            self.user_rating is not None or
            self.collection is not None or
            self.editor is not None or
            self.artist_list is not None or
            self.release_list is not None or
            self.release_group_list is not None or
            self.recording_list is not None or
            self.label_list is not None or
            self.work_list is not None or
            self.area_list is not None or
            self.place_list is not None or
            self.instrument_list is not None or
            self.series_list is not None or
            self.event_list is not None or
            self.url_list is not None or
            self.isrc_list is not None or
            self.annotation_list is not None or
            self.cdstub_list is not None or
            self.freedb_disc_list is not None or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.collection_list is not None or
            self.editor_list is not None or
            self.entity_list is not None or
            self.def_extension_element is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='metadata', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='metadata')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='metadata', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='metadata'):
        if self.generator is not None and 'generator' not in already_processed:
            already_processed.add('generator')
            outfile.write(' generator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.generator), input_name='generator')), ))
        if self.created is not None and 'created' not in already_processed:
            already_processed.add('created')
            outfile.write(' created="%s"' % self.gds_format_datetime(self.created, input_name='created'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='metadata', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.artist is not None:
            self.artist.export(outfile, level, namespace_='mmd-2.0:', name_='artist', pretty_print=pretty_print)
        if self.release is not None:
            self.release.export(outfile, level, namespace_='mmd-2.0:', name_='release', pretty_print=pretty_print)
        if self.release_group is not None:
            self.release_group.export(outfile, level, namespace_='mmd-2.0:', name_='release-group', pretty_print=pretty_print)
        if self.recording is not None:
            self.recording.export(outfile, level, namespace_='mmd-2.0:', name_='recording', pretty_print=pretty_print)
        if self.label is not None:
            self.label.export(outfile, level, namespace_='mmd-2.0:', name_='label', pretty_print=pretty_print)
        if self.work is not None:
            self.work.export(outfile, level, namespace_='mmd-2.0:', name_='work', pretty_print=pretty_print)
        if self.area is not None:
            self.area.export(outfile, level, namespace_='mmd-2.0:', name_='area', pretty_print=pretty_print)
        if self.place is not None:
            self.place.export(outfile, level, namespace_='mmd-2.0:', name_='place', pretty_print=pretty_print)
        if self.instrument is not None:
            self.instrument.export(outfile, level, namespace_='mmd-2.0:', name_='instrument', pretty_print=pretty_print)
        if self.series is not None:
            self.series.export(outfile, level, namespace_='mmd-2.0:', name_='series', pretty_print=pretty_print)
        if self.event is not None:
            self.event.export(outfile, level, namespace_='mmd-2.0:', name_='event', pretty_print=pretty_print)
        if self.url is not None:
            self.url.export(outfile, level, namespace_='mmd-2.0:', name_='url', pretty_print=pretty_print)
        if self.puid is not None:
            self.puid.export(outfile, level, namespace_='mmd-2.0:', name_='puid', pretty_print=pretty_print)
        if self.isrc is not None:
            self.isrc.export(outfile, level, namespace_='mmd-2.0:', name_='isrc', pretty_print=pretty_print)
        if self.disc is not None:
            self.disc.export(outfile, level, namespace_='mmd-2.0:', name_='disc', pretty_print=pretty_print)
        if self.rating is not None:
            self.rating.export(outfile, level, namespace_='mmd-2.0:', name_='rating', pretty_print=pretty_print)
        if self.user_rating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-rating>%s</%suser-rating>%s' % (namespace_, self.gds_format_integer(self.user_rating, input_name='user-rating'), namespace_, eol_))
        if self.collection is not None:
            self.collection.export(outfile, level, namespace_='mmd-2.0:', name_='collection', pretty_print=pretty_print)
        if self.editor is not None:
            self.editor.export(outfile, level, namespace_='mmd-2.0:', name_='editor', pretty_print=pretty_print)
        if self.artist_list is not None:
            self.artist_list.export(outfile, level, namespace_='mmd-2.0:', name_='artist-list', pretty_print=pretty_print)
        if self.release_list is not None:
            self.release_list.export(outfile, level, namespace_='mmd-2.0:', name_='release-list', pretty_print=pretty_print)
        if self.release_group_list is not None:
            self.release_group_list.export(outfile, level, namespace_='mmd-2.0:', name_='release-group-list', pretty_print=pretty_print)
        if self.recording_list is not None:
            self.recording_list.export(outfile, level, namespace_='mmd-2.0:', name_='recording-list', pretty_print=pretty_print)
        if self.label_list is not None:
            self.label_list.export(outfile, level, namespace_='mmd-2.0:', name_='label-list', pretty_print=pretty_print)
        if self.work_list is not None:
            self.work_list.export(outfile, level, namespace_='mmd-2.0:', name_='work-list', pretty_print=pretty_print)
        if self.area_list is not None:
            self.area_list.export(outfile, level, namespace_='mmd-2.0:', name_='area-list', pretty_print=pretty_print)
        if self.place_list is not None:
            self.place_list.export(outfile, level, namespace_='mmd-2.0:', name_='place-list', pretty_print=pretty_print)
        if self.instrument_list is not None:
            self.instrument_list.export(outfile, level, namespace_='mmd-2.0:', name_='instrument-list', pretty_print=pretty_print)
        if self.series_list is not None:
            self.series_list.export(outfile, level, namespace_='mmd-2.0:', name_='series-list', pretty_print=pretty_print)
        if self.event_list is not None:
            self.event_list.export(outfile, level, namespace_='mmd-2.0:', name_='event-list', pretty_print=pretty_print)
        if self.url_list is not None:
            self.url_list.export(outfile, level, namespace_='mmd-2.0:', name_='url-list', pretty_print=pretty_print)
        if self.isrc_list is not None:
            self.isrc_list.export(outfile, level, namespace_='mmd-2.0:', name_='isrc-list', pretty_print=pretty_print)
        if self.annotation_list is not None:
            self.annotation_list.export(outfile, level, namespace_='mmd-2.0:', name_='annotation-list', pretty_print=pretty_print)
        if self.cdstub_list is not None:
            self.cdstub_list.export(outfile, level, namespace_='mmd-2.0:', name_='cdstub-list', pretty_print=pretty_print)
        if self.freedb_disc_list is not None:
            self.freedb_disc_list.export(outfile, level, namespace_='mmd-2.0:', name_='freedb-disc-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            self.tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            self.user_tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='user-tag-list', pretty_print=pretty_print)
        if self.collection_list is not None:
            self.collection_list.export(outfile, level, namespace_='mmd-2.0:', name_='collection-list', pretty_print=pretty_print)
        if self.editor_list is not None:
            self.editor_list.export(outfile, level, namespace_='mmd-2.0:', name_='editor-list', pretty_print=pretty_print)
        if self.entity_list is not None:
            self.entity_list.export(outfile, level, namespace_='mmd-2.0:', name_='entity-list', pretty_print=pretty_print)
        if self.def_extension_element is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.def_extension_element), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='metadata', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.generator is not None:
            element.set('generator', self.gds_format_string(self.generator))
        if self.created is not None:
            element.set('created', self.gds_format_datetime(self.created))
        if self.artist is not None:
            artist_ = self.artist
            artist_.to_etree(element, name_='artist', mapping_=mapping_)
        if self.release is not None:
            release_ = self.release
            release_.to_etree(element, name_='release', mapping_=mapping_)
        if self.release_group is not None:
            release_group_ = self.release_group
            release_group_.to_etree(element, name_='release-group', mapping_=mapping_)
        if self.recording is not None:
            recording_ = self.recording
            recording_.to_etree(element, name_='recording', mapping_=mapping_)
        if self.label is not None:
            label_ = self.label
            label_.to_etree(element, name_='label', mapping_=mapping_)
        if self.work is not None:
            work_ = self.work
            work_.to_etree(element, name_='work', mapping_=mapping_)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_)
        if self.place is not None:
            place_ = self.place
            place_.to_etree(element, name_='place', mapping_=mapping_)
        if self.instrument is not None:
            instrument_ = self.instrument
            instrument_.to_etree(element, name_='instrument', mapping_=mapping_)
        if self.series is not None:
            series_ = self.series
            series_.to_etree(element, name_='series', mapping_=mapping_)
        if self.event is not None:
            event_ = self.event
            event_.to_etree(element, name_='event', mapping_=mapping_)
        if self.url is not None:
            url_ = self.url
            url_.to_etree(element, name_='url', mapping_=mapping_)
        if self.puid is not None:
            puid_ = self.puid
            puid_.to_etree(element, name_='puid', mapping_=mapping_)
        if self.isrc is not None:
            isrc_ = self.isrc
            isrc_.to_etree(element, name_='isrc', mapping_=mapping_)
        if self.disc is not None:
            disc_ = self.disc
            disc_.to_etree(element, name_='disc', mapping_=mapping_)
        if self.rating is not None:
            rating_ = self.rating
            rating_.to_etree(element, name_='rating', mapping_=mapping_)
        if self.user_rating is not None:
            user_rating_ = self.user_rating
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}user-rating').text = self.gds_format_integer(user_rating_)
        if self.collection is not None:
            collection_ = self.collection
            collection_.to_etree(element, name_='collection', mapping_=mapping_)
        if self.editor is not None:
            editor_ = self.editor
            editor_.to_etree(element, name_='editor', mapping_=mapping_)
        if self.artist_list is not None:
            artist_list_ = self.artist_list
            artist_list_.to_etree(element, name_='artist-list', mapping_=mapping_)
        if self.release_list is not None:
            release_list_ = self.release_list
            release_list_.to_etree(element, name_='release-list', mapping_=mapping_)
        if self.release_group_list is not None:
            release_group_list_ = self.release_group_list
            release_group_list_.to_etree(element, name_='release-group-list', mapping_=mapping_)
        if self.recording_list is not None:
            recording_list_ = self.recording_list
            recording_list_.to_etree(element, name_='recording-list', mapping_=mapping_)
        if self.label_list is not None:
            label_list_ = self.label_list
            label_list_.to_etree(element, name_='label-list', mapping_=mapping_)
        if self.work_list is not None:
            work_list_ = self.work_list
            work_list_.to_etree(element, name_='work-list', mapping_=mapping_)
        if self.area_list is not None:
            area_list_ = self.area_list
            area_list_.to_etree(element, name_='area-list', mapping_=mapping_)
        if self.place_list is not None:
            place_list_ = self.place_list
            place_list_.to_etree(element, name_='place-list', mapping_=mapping_)
        if self.instrument_list is not None:
            instrument_list_ = self.instrument_list
            instrument_list_.to_etree(element, name_='instrument-list', mapping_=mapping_)
        if self.series_list is not None:
            series_list_ = self.series_list
            series_list_.to_etree(element, name_='series-list', mapping_=mapping_)
        if self.event_list is not None:
            event_list_ = self.event_list
            event_list_.to_etree(element, name_='event-list', mapping_=mapping_)
        if self.url_list is not None:
            url_list_ = self.url_list
            url_list_.to_etree(element, name_='url-list', mapping_=mapping_)
        if self.isrc_list is not None:
            isrc_list_ = self.isrc_list
            isrc_list_.to_etree(element, name_='isrc-list', mapping_=mapping_)
        if self.annotation_list is not None:
            annotation_list_ = self.annotation_list
            annotation_list_.to_etree(element, name_='annotation-list', mapping_=mapping_)
        if self.cdstub_list is not None:
            cdstub_list_ = self.cdstub_list
            cdstub_list_.to_etree(element, name_='cdstub-list', mapping_=mapping_)
        if self.freedb_disc_list is not None:
            freedb_disc_list_ = self.freedb_disc_list
            freedb_disc_list_.to_etree(element, name_='freedb-disc-list', mapping_=mapping_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_)
        if self.collection_list is not None:
            collection_list_ = self.collection_list
            collection_list_.to_etree(element, name_='collection-list', mapping_=mapping_)
        if self.editor_list is not None:
            editor_list_ = self.editor_list
            editor_list_.to_etree(element, name_='editor-list', mapping_=mapping_)
        if self.entity_list is not None:
            entity_list_ = self.entity_list
            entity_list_.to_etree(element, name_='entity-list', mapping_=mapping_)
        if self.def_extension_element is not None:
            def_extension_element_ = self.def_extension_element
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('generator', node)
        if value is not None and 'generator' not in already_processed:
            already_processed.add('generator')
            self.generator = value
        value = find_attr_value_('created', node)
        if value is not None and 'created' not in already_processed:
            already_processed.add('created')
            try:
                self.created = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (created): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'artist':
            obj_ = artist.factory()
            obj_.build(child_)
            self.artist = obj_
            obj_.original_tagname_ = 'artist'
        elif nodeName_ == 'release':
            obj_ = release.factory()
            obj_.build(child_)
            self.release = obj_
            obj_.original_tagname_ = 'release'
        elif nodeName_ == 'release-group':
            obj_ = release_group.factory()
            obj_.build(child_)
            self.release_group = obj_
            obj_.original_tagname_ = 'release-group'
        elif nodeName_ == 'recording':
            obj_ = recording.factory()
            obj_.build(child_)
            self.recording = obj_
            obj_.original_tagname_ = 'recording'
        elif nodeName_ == 'label':
            obj_ = label.factory()
            obj_.build(child_)
            self.label = obj_
            obj_.original_tagname_ = 'label'
        elif nodeName_ == 'work':
            obj_ = work.factory()
            obj_.build(child_)
            self.work = obj_
            obj_.original_tagname_ = 'work'
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory()
            obj_.build(child_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'place':
            obj_ = place.factory()
            obj_.build(child_)
            self.place = obj_
            obj_.original_tagname_ = 'place'
        elif nodeName_ == 'instrument':
            obj_ = instrument.factory()
            obj_.build(child_)
            self.instrument = obj_
            obj_.original_tagname_ = 'instrument'
        elif nodeName_ == 'series':
            obj_ = series.factory()
            obj_.build(child_)
            self.series = obj_
            obj_.original_tagname_ = 'series'
        elif nodeName_ == 'event':
            obj_ = event.factory()
            obj_.build(child_)
            self.event = obj_
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'url':
            obj_ = url.factory()
            obj_.build(child_)
            self.url = obj_
            obj_.original_tagname_ = 'url'
        elif nodeName_ == 'puid':
            obj_ = puid.factory()
            obj_.build(child_)
            self.puid = obj_
            obj_.original_tagname_ = 'puid'
        elif nodeName_ == 'isrc':
            obj_ = isrc.factory()
            obj_.build(child_)
            self.isrc = obj_
            obj_.original_tagname_ = 'isrc'
        elif nodeName_ == 'disc':
            obj_ = disc.factory()
            obj_.build(child_)
            self.disc = obj_
            obj_.original_tagname_ = 'disc'
        elif nodeName_ == 'rating':
            obj_ = rating.factory()
            obj_.build(child_)
            self.rating = obj_
            obj_.original_tagname_ = 'rating'
        elif nodeName_ == 'user-rating':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'user_rating')
            self.user_rating = ival_
        elif nodeName_ == 'collection':
            obj_ = collection.factory()
            obj_.build(child_)
            self.collection = obj_
            obj_.original_tagname_ = 'collection'
        elif nodeName_ == 'editor':
            obj_ = editor.factory()
            obj_.build(child_)
            self.editor = obj_
            obj_.original_tagname_ = 'editor'
        elif nodeName_ == 'artist-list':
            obj_ = artist_list.factory()
            obj_.build(child_)
            self.artist_list = obj_
            obj_.original_tagname_ = 'artist-list'
        elif nodeName_ == 'release-list':
            obj_ = release_list.factory()
            obj_.build(child_)
            self.release_list = obj_
            obj_.original_tagname_ = 'release-list'
        elif nodeName_ == 'release-group-list':
            obj_ = release_group_list.factory()
            obj_.build(child_)
            self.release_group_list = obj_
            obj_.original_tagname_ = 'release-group-list'
        elif nodeName_ == 'recording-list':
            obj_ = recording_list.factory()
            obj_.build(child_)
            self.recording_list = obj_
            obj_.original_tagname_ = 'recording-list'
        elif nodeName_ == 'label-list':
            obj_ = label_list.factory()
            obj_.build(child_)
            self.label_list = obj_
            obj_.original_tagname_ = 'label-list'
        elif nodeName_ == 'work-list':
            obj_ = work_list.factory()
            obj_.build(child_)
            self.work_list = obj_
            obj_.original_tagname_ = 'work-list'
        elif nodeName_ == 'area-list':
            obj_ = area_list.factory()
            obj_.build(child_)
            self.area_list = obj_
            obj_.original_tagname_ = 'area-list'
        elif nodeName_ == 'place-list':
            obj_ = place_list.factory()
            obj_.build(child_)
            self.place_list = obj_
            obj_.original_tagname_ = 'place-list'
        elif nodeName_ == 'instrument-list':
            obj_ = instrument_list.factory()
            obj_.build(child_)
            self.instrument_list = obj_
            obj_.original_tagname_ = 'instrument-list'
        elif nodeName_ == 'series-list':
            obj_ = series_list.factory()
            obj_.build(child_)
            self.series_list = obj_
            obj_.original_tagname_ = 'series-list'
        elif nodeName_ == 'event-list':
            obj_ = event_list.factory()
            obj_.build(child_)
            self.event_list = obj_
            obj_.original_tagname_ = 'event-list'
        elif nodeName_ == 'url-list':
            obj_ = url_list.factory()
            obj_.build(child_)
            self.url_list = obj_
            obj_.original_tagname_ = 'url-list'
        elif nodeName_ == 'isrc-list':
            obj_ = isrc_list.factory()
            obj_.build(child_)
            self.isrc_list = obj_
            obj_.original_tagname_ = 'isrc-list'
        elif nodeName_ == 'annotation-list':
            obj_ = annotation_list.factory()
            obj_.build(child_)
            self.annotation_list = obj_
            obj_.original_tagname_ = 'annotation-list'
        elif nodeName_ == 'cdstub-list':
            obj_ = cdstub_list.factory()
            obj_.build(child_)
            self.cdstub_list = obj_
            obj_.original_tagname_ = 'cdstub-list'
        elif nodeName_ == 'freedb-disc-list':
            obj_ = freedb_disc_list.factory()
            obj_.build(child_)
            self.freedb_disc_list = obj_
            obj_.original_tagname_ = 'freedb-disc-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory()
            obj_.build(child_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory()
            obj_.build(child_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'collection-list':
            obj_ = collection_list.factory()
            obj_.build(child_)
            self.collection_list = obj_
            obj_.original_tagname_ = 'collection-list'
        elif nodeName_ == 'editor-list':
            obj_ = editor_list.factory()
            obj_.build(child_)
            self.editor_list = obj_
            obj_.original_tagname_ = 'editor-list'
        elif nodeName_ == 'entity-list':
            obj_ = entity_list.factory()
            obj_.build(child_)
            self.entity_list = obj_
            obj_.original_tagname_ = 'entity-list'
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element = def_extension_element_
# end class metadata


class artist(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, sort_name=None, gender=None, country=None, area=None, begin_area=None, end_area=None, annotation=None, disambiguation=None, ipi=None, ipi_list=None, life_span=None, alias_list=None, recording_list=None, release_list=None, release_group_list=None, label_list=None, work_list=None, relation_list=None, tag_list=None, user_tag_list=None, rating=None, user_rating=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.name = name
        self.sort_name = sort_name
        self.gender = gender
        self.country = country
        self.validate_def_iso_3166_1_code(self.country)
        self.area = area
        self.begin_area = begin_area
        self.end_area = end_area
        self.annotation = annotation
        self.disambiguation = disambiguation
        self.ipi = ipi
        self.validate_def_ipi(self.ipi)
        self.ipi_list = ipi_list
        self.life_span = life_span
        self.alias_list = alias_list
        self.recording_list = recording_list
        self.release_list = release_list
        self.release_group_list = release_group_list
        self.label_list = label_list
        self.work_list = work_list
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.tag_list = tag_list
        self.user_tag_list = user_tag_list
        self.rating = rating
        self.user_rating = user_rating
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, artist)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if artist.subclass:
            return artist.subclass(*args_, **kwargs_)
        else:
            return artist(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_sort_name(self): return self.sort_name
    def set_sort_name(self, sort_name): self.sort_name = sort_name
    def get_gender(self): return self.gender
    def set_gender(self, gender): self.gender = gender
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_area(self): return self.area
    def set_area(self, area): self.area = area
    def get_begin_area(self): return self.begin_area
    def set_begin_area(self, begin_area): self.begin_area = begin_area
    def get_end_area(self): return self.end_area
    def set_end_area(self, end_area): self.end_area = end_area
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def get_disambiguation(self): return self.disambiguation
    def set_disambiguation(self, disambiguation): self.disambiguation = disambiguation
    def get_ipi(self): return self.ipi
    def set_ipi(self, ipi): self.ipi = ipi
    def get_ipi_list(self): return self.ipi_list
    def set_ipi_list(self, ipi_list): self.ipi_list = ipi_list
    def get_life_span(self): return self.life_span
    def set_life_span(self, life_span): self.life_span = life_span
    def get_alias_list(self): return self.alias_list
    def set_alias_list(self, alias_list): self.alias_list = alias_list
    def get_recording_list(self): return self.recording_list
    def set_recording_list(self, recording_list): self.recording_list = recording_list
    def get_release_list(self): return self.release_list
    def set_release_list(self, release_list): self.release_list = release_list
    def get_release_group_list(self): return self.release_group_list
    def set_release_group_list(self, release_group_list): self.release_group_list = release_group_list
    def get_label_list(self): return self.label_list
    def set_label_list(self, label_list): self.label_list = label_list
    def get_work_list(self): return self.work_list
    def set_work_list(self, work_list): self.work_list = work_list
    def get_relation_list(self): return self.relation_list
    def set_relation_list(self, relation_list): self.relation_list = relation_list
    def add_relation_list(self, value): self.relation_list.append(value)
    def insert_relation_list_at(self, index, value): self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value): self.relation_list[index] = value
    def get_tag_list(self): return self.tag_list
    def set_tag_list(self, tag_list): self.tag_list = tag_list
    def get_user_tag_list(self): return self.user_tag_list
    def set_user_tag_list(self, user_tag_list): self.user_tag_list = user_tag_list
    def get_rating(self): return self.rating
    def set_rating(self, rating): self.rating = rating
    def get_user_rating(self): return self.user_rating
    def set_user_rating(self, user_rating): self.user_rating = user_rating
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def validate_def_iso_3166_1_code(self, value):
        # Validate type def_iso-3166-1-code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_3166_1_code_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_iso_3166_1_code_patterns_, ))
    validate_def_iso_3166_1_code_patterns_ = [['^[A-Z]{2}$']]
    def validate_def_ipi(self, value):
        # Validate type def_ipi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_ipi_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_ipi_patterns_, ))
    validate_def_ipi_patterns_ = [['^[0-9]{11}$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.sort_name is not None or
            self.gender is not None or
            self.country is not None or
            self.area is not None or
            self.begin_area is not None or
            self.end_area is not None or
            self.annotation is not None or
            self.disambiguation is not None or
            self.ipi is not None or
            self.ipi_list is not None or
            self.life_span is not None or
            self.alias_list is not None or
            self.recording_list is not None or
            self.release_list is not None or
            self.release_group_list is not None or
            self.label_list is not None or
            self.work_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.rating is not None or
            self.user_rating is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='artist', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='artist')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='artist', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='artist'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='artist', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.sort_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssort-name>%s</%ssort-name>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.sort_name), input_name='sort-name')), namespace_, eol_))
        if self.gender is not None:
            self.gender.export(outfile, level, namespace_='mmd-2.0:', name_='gender', pretty_print=pretty_print)
        if self.country is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scountry>%s</%scountry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.country), input_name='country')), namespace_, eol_))
        if self.area is not None:
            self.area.export(outfile, level, namespace_='mmd-2.0:', name_='area', pretty_print=pretty_print)
        if self.begin_area is not None:
            self.begin_area.export(outfile, level, namespace_='mmd-2.0:', name_='begin-area', pretty_print=pretty_print)
        if self.end_area is not None:
            self.end_area.export(outfile, level, namespace_='mmd-2.0:', name_='end-area', pretty_print=pretty_print)
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_='mmd-2.0:', name_='annotation', pretty_print=pretty_print)
        if self.disambiguation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespace_, eol_))
        if self.ipi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sipi>%s</%sipi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ipi), input_name='ipi')), namespace_, eol_))
        if self.ipi_list is not None:
            self.ipi_list.export(outfile, level, namespace_='mmd-2.0:', name_='ipi-list', pretty_print=pretty_print)
        if self.life_span is not None:
            self.life_span.export(outfile, level, namespace_='mmd-2.0:', name_='life-span', pretty_print=pretty_print)
        if self.alias_list is not None:
            self.alias_list.export(outfile, level, namespace_='mmd-2.0:', name_='alias-list', pretty_print=pretty_print)
        if self.recording_list is not None:
            self.recording_list.export(outfile, level, namespace_='mmd-2.0:', name_='recording-list', pretty_print=pretty_print)
        if self.release_list is not None:
            self.release_list.export(outfile, level, namespace_='mmd-2.0:', name_='release-list', pretty_print=pretty_print)
        if self.release_group_list is not None:
            self.release_group_list.export(outfile, level, namespace_='mmd-2.0:', name_='release-group-list', pretty_print=pretty_print)
        if self.label_list is not None:
            self.label_list.export(outfile, level, namespace_='mmd-2.0:', name_='label-list', pretty_print=pretty_print)
        if self.work_list is not None:
            self.work_list.export(outfile, level, namespace_='mmd-2.0:', name_='work-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            relation_list_.export(outfile, level, namespace_='mmd-2.0:', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            self.tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            self.user_tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='user-tag-list', pretty_print=pretty_print)
        if self.rating is not None:
            self.rating.export(outfile, level, namespace_='mmd-2.0:', name_='rating', pretty_print=pretty_print)
        if self.user_rating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-rating>%s</%suser-rating>%s' % (namespace_, self.gds_format_integer(self.user_rating, input_name='user-rating'), namespace_, eol_))
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='artist', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.sort_name is not None:
            sort_name_ = self.sort_name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}sort-name').text = self.gds_format_string(sort_name_)
        if self.gender is not None:
            gender_ = self.gender
            gender_.to_etree(element, name_='gender', mapping_=mapping_)
        if self.country is not None:
            country_ = self.country
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}country').text = self.gds_format_string(country_)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_)
        if self.begin_area is not None:
            begin_area_ = self.begin_area
            begin_area_.to_etree(element, name_='begin-area', mapping_=mapping_)
        if self.end_area is not None:
            end_area_ = self.end_area
            end_area_.to_etree(element, name_='end-area', mapping_=mapping_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.ipi is not None:
            ipi_ = self.ipi
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}ipi').text = self.gds_format_string(ipi_)
        if self.ipi_list is not None:
            ipi_list_ = self.ipi_list
            ipi_list_.to_etree(element, name_='ipi-list', mapping_=mapping_)
        if self.life_span is not None:
            life_span_ = self.life_span
            life_span_.to_etree(element, name_='life-span', mapping_=mapping_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_)
        if self.recording_list is not None:
            recording_list_ = self.recording_list
            recording_list_.to_etree(element, name_='recording-list', mapping_=mapping_)
        if self.release_list is not None:
            release_list_ = self.release_list
            release_list_.to_etree(element, name_='release-list', mapping_=mapping_)
        if self.release_group_list is not None:
            release_group_list_ = self.release_group_list
            release_group_list_.to_etree(element, name_='release-group-list', mapping_=mapping_)
        if self.label_list is not None:
            label_list_ = self.label_list
            label_list_.to_etree(element, name_='label-list', mapping_=mapping_)
        if self.work_list is not None:
            work_list_ = self.work_list
            work_list_.to_etree(element, name_='work-list', mapping_=mapping_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_)
        if self.rating is not None:
            rating_ = self.rating
            rating_.to_etree(element, name_='rating', mapping_=mapping_)
        if self.user_rating is not None:
            user_rating_ = self.user_rating
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}user-rating').text = self.gds_format_integer(user_rating_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'sort-name':
            sort_name_ = child_.text
            sort_name_ = self.gds_validate_string(sort_name_, node, 'sort_name')
            self.sort_name = sort_name_
        elif nodeName_ == 'gender':
            obj_ = gender.factory()
            obj_.build(child_)
            self.gender = obj_
            obj_.original_tagname_ = 'gender'
        elif nodeName_ == 'country':
            country_ = child_.text
            country_ = self.gds_validate_string(country_, node, 'country')
            self.country = country_
            # validate type def_iso-3166-1-code
            self.validate_def_iso_3166_1_code(self.country)
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory()
            obj_.build(child_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'begin-area':
            obj_ = def_area_element_inner.factory()
            obj_.build(child_)
            self.begin_area = obj_
            obj_.original_tagname_ = 'begin-area'
        elif nodeName_ == 'end-area':
            obj_ = def_area_element_inner.factory()
            obj_.build(child_)
            self.end_area = obj_
            obj_.original_tagname_ = 'end-area'
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory()
            obj_.build(child_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'disambiguation':
            disambiguation_ = child_.text
            disambiguation_ = self.gds_validate_string(disambiguation_, node, 'disambiguation')
            self.disambiguation = disambiguation_
        elif nodeName_ == 'ipi':
            ipi_ = child_.text
            ipi_ = self.gds_validate_string(ipi_, node, 'ipi')
            self.ipi = ipi_
            # validate type def_ipi
            self.validate_def_ipi(self.ipi)
        elif nodeName_ == 'ipi-list':
            obj_ = ipi_list.factory()
            obj_.build(child_)
            self.ipi_list = obj_
            obj_.original_tagname_ = 'ipi-list'
        elif nodeName_ == 'life-span':
            obj_ = life_spanType.factory()
            obj_.build(child_)
            self.life_span = obj_
            obj_.original_tagname_ = 'life-span'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory()
            obj_.build(child_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'recording-list':
            obj_ = recording_list.factory()
            obj_.build(child_)
            self.recording_list = obj_
            obj_.original_tagname_ = 'recording-list'
        elif nodeName_ == 'release-list':
            obj_ = release_list.factory()
            obj_.build(child_)
            self.release_list = obj_
            obj_.original_tagname_ = 'release-list'
        elif nodeName_ == 'release-group-list':
            obj_ = release_group_list.factory()
            obj_.build(child_)
            self.release_group_list = obj_
            obj_.original_tagname_ = 'release-group-list'
        elif nodeName_ == 'label-list':
            obj_ = label_list.factory()
            obj_.build(child_)
            self.label_list = obj_
            obj_.original_tagname_ = 'label-list'
        elif nodeName_ == 'work-list':
            obj_ = work_list.factory()
            obj_.build(child_)
            self.work_list = obj_
            obj_.original_tagname_ = 'work-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory()
            obj_.build(child_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory()
            obj_.build(child_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory()
            obj_.build(child_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'rating':
            obj_ = rating.factory()
            obj_.build(child_)
            self.rating = obj_
            obj_.original_tagname_ = 'rating'
        elif nodeName_ == 'user-rating':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'user_rating')
            self.user_rating = ival_
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class artist


class gender(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, gender)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if gender.subclass:
            return gender.subclass(*args_, **kwargs_)
        else:
            return gender(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='gender', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gender')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='gender'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='gender', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='gender', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.id)
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class gender


class life_span(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, begin=None, end=None, ended=None):
        self.original_tagname_ = None
        self.begin = begin
        self.validate_def_incomplete_date(self.begin)
        self.end = end
        self.validate_def_incomplete_date(self.end)
        self.ended = ended
        self.validate_ended(self.ended)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, life_span)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if life_span.subclass:
            return life_span.subclass(*args_, **kwargs_)
        else:
            return life_span(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_ended(self): return self.ended
    def set_ended(self, ended): self.ended = ended
    def validate_def_incomplete_date(self, value):
        # Validate type def_incomplete-date, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_incomplete_date_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_incomplete_date_patterns_, ))
    validate_def_incomplete_date_patterns_ = [['^[0-9]{4}(-[0-9]{2})?(-[0-9]{2})?$']]
    def validate_ended(self, value):
        # Validate type ended, a restriction on xs:token.
        pass
    def hasContent_(self):
        if (
            self.begin is not None or
            self.end is not None or
            self.ended is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='life-span', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='life-span')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='life-span', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='life-span'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='life-span', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.begin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbegin>%s</%sbegin>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.begin), input_name='begin')), namespace_, eol_))
        if self.end is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%send>%s</%send>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.end), input_name='end')), namespace_, eol_))
        if self.ended is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sended>%s</%sended>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ended), input_name='ended')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='life-span', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.begin is not None:
            begin_ = self.begin
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}begin').text = self.gds_format_string(begin_)
        if self.end is not None:
            end_ = self.end
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}end').text = self.gds_format_string(end_)
        if self.ended is not None:
            ended_ = self.ended
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}ended').text = self.gds_format_string(ended_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'begin':
            begin_ = child_.text
            begin_ = self.gds_validate_string(begin_, node, 'begin')
            self.begin = begin_
            # validate type def_incomplete-date
            self.validate_def_incomplete_date(self.begin)
        elif nodeName_ == 'end':
            end_ = child_.text
            end_ = self.gds_validate_string(end_, node, 'end')
            self.end = end_
            # validate type def_incomplete-date
            self.validate_def_incomplete_date(self.end)
        elif nodeName_ == 'ended':
            ended_ = child_.text
            if ended_:
                ended_ = re_.sub(String_cleanup_pat_, " ", ended_).strip()
            else:
                ended_ = ""
            ended_ = self.gds_validate_string(ended_, node, 'ended')
            self.ended = ended_
            # validate type ended
            self.validate_ended(self.ended)
# end class life_span


class release(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, title=None, status=None, quality=None, annotation=None, disambiguation=None, packaging=None, text_representation=None, artist_credit=None, alias_list=None, release_group=None, date=None, country=None, release_event_list=None, barcode=None, asin=None, cover_art_archive=None, label_info_list=None, medium_list=None, relation_list=None, tag_list=None, user_tag_list=None, collection_list=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.title = title
        self.status = status
        self.quality = quality
        self.validate_def_quality(self.quality)
        self.annotation = annotation
        self.disambiguation = disambiguation
        self.packaging = packaging
        self.text_representation = text_representation
        self.artist_credit = artist_credit
        self.alias_list = alias_list
        self.release_group = release_group
        self.date = date
        self.validate_def_incomplete_date(self.date)
        self.country = country
        self.validate_def_iso_3166_1_code(self.country)
        self.release_event_list = release_event_list
        self.barcode = barcode
        self.asin = asin
        self.validate_asin(self.asin)
        self.cover_art_archive = cover_art_archive
        self.label_info_list = label_info_list
        self.medium_list = medium_list
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.tag_list = tag_list
        self.user_tag_list = user_tag_list
        self.collection_list = collection_list
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, release)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if release.subclass:
            return release.subclass(*args_, **kwargs_)
        else:
            return release(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_quality(self): return self.quality
    def set_quality(self, quality): self.quality = quality
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def get_disambiguation(self): return self.disambiguation
    def set_disambiguation(self, disambiguation): self.disambiguation = disambiguation
    def get_packaging(self): return self.packaging
    def set_packaging(self, packaging): self.packaging = packaging
    def get_text_representation(self): return self.text_representation
    def set_text_representation(self, text_representation): self.text_representation = text_representation
    def get_artist_credit(self): return self.artist_credit
    def set_artist_credit(self, artist_credit): self.artist_credit = artist_credit
    def get_alias_list(self): return self.alias_list
    def set_alias_list(self, alias_list): self.alias_list = alias_list
    def get_release_group(self): return self.release_group
    def set_release_group(self, release_group): self.release_group = release_group
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_release_event_list(self): return self.release_event_list
    def set_release_event_list(self, release_event_list): self.release_event_list = release_event_list
    def get_barcode(self): return self.barcode
    def set_barcode(self, barcode): self.barcode = barcode
    def get_asin(self): return self.asin
    def set_asin(self, asin): self.asin = asin
    def get_cover_art_archive(self): return self.cover_art_archive
    def set_cover_art_archive(self, cover_art_archive): self.cover_art_archive = cover_art_archive
    def get_label_info_list(self): return self.label_info_list
    def set_label_info_list(self, label_info_list): self.label_info_list = label_info_list
    def get_medium_list(self): return self.medium_list
    def set_medium_list(self, medium_list): self.medium_list = medium_list
    def get_relation_list(self): return self.relation_list
    def set_relation_list(self, relation_list): self.relation_list = relation_list
    def add_relation_list(self, value): self.relation_list.append(value)
    def insert_relation_list_at(self, index, value): self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value): self.relation_list[index] = value
    def get_tag_list(self): return self.tag_list
    def set_tag_list(self, tag_list): self.tag_list = tag_list
    def get_user_tag_list(self): return self.user_tag_list
    def set_user_tag_list(self, user_tag_list): self.user_tag_list = user_tag_list
    def get_collection_list(self): return self.collection_list
    def set_collection_list(self, collection_list): self.collection_list = collection_list
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_def_quality(self, value):
        # Validate type def_quality, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['low', 'normal', 'high']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on def_quality' % {"value" : value.encode("utf-8")} )
    def validate_def_incomplete_date(self, value):
        # Validate type def_incomplete-date, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_incomplete_date_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_incomplete_date_patterns_, ))
    validate_def_incomplete_date_patterns_ = [['^[0-9]{4}(-[0-9]{2})?(-[0-9]{2})?$']]
    def validate_def_iso_3166_1_code(self, value):
        # Validate type def_iso-3166-1-code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_3166_1_code_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_iso_3166_1_code_patterns_, ))
    validate_def_iso_3166_1_code_patterns_ = [['^[A-Z]{2}$']]
    def validate_asin(self, value):
        # Validate type asin, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.title is not None or
            self.status is not None or
            self.quality is not None or
            self.annotation is not None or
            self.disambiguation is not None or
            self.packaging is not None or
            self.text_representation is not None or
            self.artist_credit is not None or
            self.alias_list is not None or
            self.release_group is not None or
            self.date is not None or
            self.country is not None or
            self.release_event_list is not None or
            self.barcode is not None or
            self.asin is not None or
            self.cover_art_archive is not None or
            self.label_info_list is not None or
            self.medium_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.collection_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='release', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='release')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='release', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='release'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='release', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespace_, eol_))
        if self.status is not None:
            self.status.export(outfile, level, namespace_='mmd-2.0:', name_='status', pretty_print=pretty_print)
        if self.quality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squality>%s</%squality>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.quality), input_name='quality')), namespace_, eol_))
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_='mmd-2.0:', name_='annotation', pretty_print=pretty_print)
        if self.disambiguation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespace_, eol_))
        if self.packaging is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spackaging>%s</%spackaging>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.packaging), input_name='packaging')), namespace_, eol_))
        if self.text_representation is not None:
            self.text_representation.export(outfile, level, namespace_='mmd-2.0:', name_='text-representation', pretty_print=pretty_print)
        if self.artist_credit is not None:
            self.artist_credit.export(outfile, level, namespace_='mmd-2.0:', name_='artist-credit', pretty_print=pretty_print)
        if self.alias_list is not None:
            self.alias_list.export(outfile, level, namespace_='mmd-2.0:', name_='alias-list', pretty_print=pretty_print)
        if self.release_group is not None:
            self.release_group.export(outfile, level, namespace_='mmd-2.0:', name_='release-group', pretty_print=pretty_print)
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.date), input_name='date')), namespace_, eol_))
        if self.country is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scountry>%s</%scountry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.country), input_name='country')), namespace_, eol_))
        if self.release_event_list is not None:
            self.release_event_list.export(outfile, level, namespace_='mmd-2.0:', name_='release-event-list', pretty_print=pretty_print)
        if self.barcode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbarcode>%s</%sbarcode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.barcode), input_name='barcode')), namespace_, eol_))
        if self.asin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sasin>%s</%sasin>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.asin), input_name='asin')), namespace_, eol_))
        if self.cover_art_archive is not None:
            self.cover_art_archive.export(outfile, level, namespace_='mmd-2.0:', name_='cover-art-archive', pretty_print=pretty_print)
        if self.label_info_list is not None:
            self.label_info_list.export(outfile, level, namespace_='mmd-2.0:', name_='label-info-list', pretty_print=pretty_print)
        if self.medium_list is not None:
            self.medium_list.export(outfile, level, namespace_='mmd-2.0:', name_='medium-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            relation_list_.export(outfile, level, namespace_='mmd-2.0:', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            self.tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            self.user_tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='user-tag-list', pretty_print=pretty_print)
        if self.collection_list is not None:
            self.collection_list.export(outfile, level, namespace_='mmd-2.0:', name_='collection-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='release', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.status is not None:
            status_ = self.status
            status_.to_etree(element, name_='status', mapping_=mapping_)
        if self.quality is not None:
            quality_ = self.quality
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}quality').text = self.gds_format_string(quality_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.packaging is not None:
            packaging_ = self.packaging
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}packaging').text = self.gds_format_string(packaging_)
        if self.text_representation is not None:
            text_representation_ = self.text_representation
            text_representation_.to_etree(element, name_='text-representation', mapping_=mapping_)
        if self.artist_credit is not None:
            artist_credit_ = self.artist_credit
            artist_credit_.to_etree(element, name_='artist-credit', mapping_=mapping_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_)
        if self.release_group is not None:
            release_group_ = self.release_group
            release_group_.to_etree(element, name_='release-group', mapping_=mapping_)
        if self.date is not None:
            date_ = self.date
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}date').text = self.gds_format_string(date_)
        if self.country is not None:
            country_ = self.country
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}country').text = self.gds_format_string(country_)
        if self.release_event_list is not None:
            release_event_list_ = self.release_event_list
            release_event_list_.to_etree(element, name_='release-event-list', mapping_=mapping_)
        if self.barcode is not None:
            barcode_ = self.barcode
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}barcode').text = self.gds_format_string(barcode_)
        if self.asin is not None:
            asin_ = self.asin
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}asin').text = self.gds_format_string(asin_)
        if self.cover_art_archive is not None:
            cover_art_archive_ = self.cover_art_archive
            cover_art_archive_.to_etree(element, name_='cover-art-archive', mapping_=mapping_)
        if self.label_info_list is not None:
            label_info_list_ = self.label_info_list
            label_info_list_.to_etree(element, name_='label-info-list', mapping_=mapping_)
        if self.medium_list is not None:
            medium_list_ = self.medium_list
            medium_list_.to_etree(element, name_='medium-list', mapping_=mapping_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_)
        if self.collection_list is not None:
            collection_list_ = self.collection_list
            collection_list_.to_etree(element, name_='collection-list', mapping_=mapping_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'status':
            obj_ = status.factory()
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'quality':
            quality_ = child_.text
            if quality_:
                quality_ = re_.sub(String_cleanup_pat_, " ", quality_).strip()
            else:
                quality_ = ""
            quality_ = self.gds_validate_string(quality_, node, 'quality')
            self.quality = quality_
            # validate type def_quality
            self.validate_def_quality(self.quality)
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory()
            obj_.build(child_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'disambiguation':
            disambiguation_ = child_.text
            disambiguation_ = self.gds_validate_string(disambiguation_, node, 'disambiguation')
            self.disambiguation = disambiguation_
        elif nodeName_ == 'packaging':
            packaging_ = child_.text
            packaging_ = self.gds_validate_string(packaging_, node, 'packaging')
            self.packaging = packaging_
        elif nodeName_ == 'text-representation':
            obj_ = text_representation.factory()
            obj_.build(child_)
            self.text_representation = obj_
            obj_.original_tagname_ = 'text-representation'
        elif nodeName_ == 'artist-credit':
            obj_ = artist_credit.factory()
            obj_.build(child_)
            self.artist_credit = obj_
            obj_.original_tagname_ = 'artist-credit'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory()
            obj_.build(child_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'release-group':
            obj_ = release_group.factory()
            obj_.build(child_)
            self.release_group = obj_
            obj_.original_tagname_ = 'release-group'
        elif nodeName_ == 'date':
            date_ = child_.text
            date_ = self.gds_validate_string(date_, node, 'date')
            self.date = date_
            # validate type def_incomplete-date
            self.validate_def_incomplete_date(self.date)
        elif nodeName_ == 'country':
            country_ = child_.text
            country_ = self.gds_validate_string(country_, node, 'country')
            self.country = country_
            # validate type def_iso-3166-1-code
            self.validate_def_iso_3166_1_code(self.country)
        elif nodeName_ == 'release-event-list':
            obj_ = release_event_list.factory()
            obj_.build(child_)
            self.release_event_list = obj_
            obj_.original_tagname_ = 'release-event-list'
        elif nodeName_ == 'barcode':
            barcode_ = child_.text
            barcode_ = self.gds_validate_string(barcode_, node, 'barcode')
            self.barcode = barcode_
        elif nodeName_ == 'asin':
            asin_ = child_.text
            asin_ = self.gds_validate_string(asin_, node, 'asin')
            self.asin = asin_
            # validate type asin
            self.validate_asin(self.asin)
        elif nodeName_ == 'cover-art-archive':
            obj_ = cover_art_archive.factory()
            obj_.build(child_)
            self.cover_art_archive = obj_
            obj_.original_tagname_ = 'cover-art-archive'
        elif nodeName_ == 'label-info-list':
            obj_ = label_info_list.factory()
            obj_.build(child_)
            self.label_info_list = obj_
            obj_.original_tagname_ = 'label-info-list'
        elif nodeName_ == 'medium-list':
            obj_ = medium_list.factory()
            obj_.build(child_)
            self.medium_list = obj_
            obj_.original_tagname_ = 'medium-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory()
            obj_.build(child_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory()
            obj_.build(child_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory()
            obj_.build(child_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'collection-list':
            obj_ = collection_list.factory()
            obj_.build(child_)
            self.collection_list = obj_
            obj_.original_tagname_ = 'collection-list'
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class release


class status(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, status)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if status.subclass:
            return status.subclass(*args_, **kwargs_)
        else:
            return status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='status', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='status')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='status'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='status', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='status', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.id)
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class status


class text_representation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, language=None, script=None):
        self.original_tagname_ = None
        self.language = language
        self.validate_def_iso_639(self.language)
        self.script = script
        self.validate_def_iso_15924(self.script)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, text_representation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if text_representation.subclass:
            return text_representation.subclass(*args_, **kwargs_)
        else:
            return text_representation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_script(self): return self.script
    def set_script(self, script): self.script = script
    def validate_def_iso_639(self, value):
        # Validate type def_iso-639, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_639_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_iso_639_patterns_, ))
    validate_def_iso_639_patterns_ = [['^[a-z]{3}$']]
    def validate_def_iso_15924(self, value):
        # Validate type def_iso-15924, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_15924_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_iso_15924_patterns_, ))
    validate_def_iso_15924_patterns_ = [['^[A-Z][a-z]{3}$']]
    def hasContent_(self):
        if (
            self.language is not None or
            self.script is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='text-representation', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='text-representation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='text-representation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='text-representation'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='text-representation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.language is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.language), input_name='language')), namespace_, eol_))
        if self.script is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscript>%s</%sscript>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.script), input_name='script')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='text-representation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.language is not None:
            language_ = self.language
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}language').text = self.gds_format_string(language_)
        if self.script is not None:
            script_ = self.script
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}script').text = self.gds_format_string(script_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'language':
            language_ = child_.text
            language_ = self.gds_validate_string(language_, node, 'language')
            self.language = language_
            # validate type def_iso-639
            self.validate_def_iso_639(self.language)
        elif nodeName_ == 'script':
            script_ = child_.text
            script_ = self.gds_validate_string(script_, node, 'script')
            self.script = script_
            # validate type def_iso-15924
            self.validate_def_iso_15924(self.script)
# end class text_representation


class asin(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, asin)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if asin.subclass:
            return asin.subclass(*args_, **kwargs_)
        else:
            return asin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='asin', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='asin')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='asin', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='asin'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='asin', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='asin', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class asin


class release_group(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, title=None, annotation=None, disambiguation=None, first_release_date=None, primary_type=None, secondary_type_list=None, artist_credit=None, release_list=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, rating=None, user_rating=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.title = title
        self.annotation = annotation
        self.disambiguation = disambiguation
        self.first_release_date = first_release_date
        self.validate_def_incomplete_date(self.first_release_date)
        self.primary_type = primary_type
        self.secondary_type_list = secondary_type_list
        self.artist_credit = artist_credit
        self.release_list = release_list
        self.alias_list = alias_list
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.tag_list = tag_list
        self.user_tag_list = user_tag_list
        self.rating = rating
        self.user_rating = user_rating
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, release_group)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if release_group.subclass:
            return release_group.subclass(*args_, **kwargs_)
        else:
            return release_group(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def get_disambiguation(self): return self.disambiguation
    def set_disambiguation(self, disambiguation): self.disambiguation = disambiguation
    def get_first_release_date(self): return self.first_release_date
    def set_first_release_date(self, first_release_date): self.first_release_date = first_release_date
    def get_primary_type(self): return self.primary_type
    def set_primary_type(self, primary_type): self.primary_type = primary_type
    def get_secondary_type_list(self): return self.secondary_type_list
    def set_secondary_type_list(self, secondary_type_list): self.secondary_type_list = secondary_type_list
    def get_artist_credit(self): return self.artist_credit
    def set_artist_credit(self, artist_credit): self.artist_credit = artist_credit
    def get_release_list(self): return self.release_list
    def set_release_list(self, release_list): self.release_list = release_list
    def get_alias_list(self): return self.alias_list
    def set_alias_list(self, alias_list): self.alias_list = alias_list
    def get_relation_list(self): return self.relation_list
    def set_relation_list(self, relation_list): self.relation_list = relation_list
    def add_relation_list(self, value): self.relation_list.append(value)
    def insert_relation_list_at(self, index, value): self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value): self.relation_list[index] = value
    def get_tag_list(self): return self.tag_list
    def set_tag_list(self, tag_list): self.tag_list = tag_list
    def get_user_tag_list(self): return self.user_tag_list
    def set_user_tag_list(self, user_tag_list): self.user_tag_list = user_tag_list
    def get_rating(self): return self.rating
    def set_rating(self, rating): self.rating = rating
    def get_user_rating(self): return self.user_rating
    def set_user_rating(self, user_rating): self.user_rating = user_rating
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def validate_def_incomplete_date(self, value):
        # Validate type def_incomplete-date, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_incomplete_date_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_incomplete_date_patterns_, ))
    validate_def_incomplete_date_patterns_ = [['^[0-9]{4}(-[0-9]{2})?(-[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.title is not None or
            self.annotation is not None or
            self.disambiguation is not None or
            self.first_release_date is not None or
            self.primary_type is not None or
            self.secondary_type_list is not None or
            self.artist_credit is not None or
            self.release_list is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.rating is not None or
            self.user_rating is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='release-group', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='release-group')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='release-group', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='release-group'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='release-group', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespace_, eol_))
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_='mmd-2.0:', name_='annotation', pretty_print=pretty_print)
        if self.disambiguation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespace_, eol_))
        if self.first_release_date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfirst-release-date>%s</%sfirst-release-date>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.first_release_date), input_name='first-release-date')), namespace_, eol_))
        if self.primary_type is not None:
            self.primary_type.export(outfile, level, namespace_='mmd-2.0:', name_='primary-type', pretty_print=pretty_print)
        if self.secondary_type_list is not None:
            self.secondary_type_list.export(outfile, level, namespace_='mmd-2.0:', name_='secondary-type-list', pretty_print=pretty_print)
        if self.artist_credit is not None:
            self.artist_credit.export(outfile, level, namespace_='mmd-2.0:', name_='artist-credit', pretty_print=pretty_print)
        if self.release_list is not None:
            self.release_list.export(outfile, level, namespace_='mmd-2.0:', name_='release-list', pretty_print=pretty_print)
        if self.alias_list is not None:
            self.alias_list.export(outfile, level, namespace_='mmd-2.0:', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            relation_list_.export(outfile, level, namespace_='mmd-2.0:', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            self.tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            self.user_tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='user-tag-list', pretty_print=pretty_print)
        if self.rating is not None:
            self.rating.export(outfile, level, namespace_='mmd-2.0:', name_='rating', pretty_print=pretty_print)
        if self.user_rating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-rating>%s</%suser-rating>%s' % (namespace_, self.gds_format_integer(self.user_rating, input_name='user-rating'), namespace_, eol_))
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='release-group', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.first_release_date is not None:
            first_release_date_ = self.first_release_date
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}first-release-date').text = self.gds_format_string(first_release_date_)
        if self.primary_type is not None:
            primary_type_ = self.primary_type
            primary_type_.to_etree(element, name_='primary-type', mapping_=mapping_)
        if self.secondary_type_list is not None:
            secondary_type_list_ = self.secondary_type_list
            secondary_type_list_.to_etree(element, name_='secondary-type-list', mapping_=mapping_)
        if self.artist_credit is not None:
            artist_credit_ = self.artist_credit
            artist_credit_.to_etree(element, name_='artist-credit', mapping_=mapping_)
        if self.release_list is not None:
            release_list_ = self.release_list
            release_list_.to_etree(element, name_='release-list', mapping_=mapping_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_)
        if self.rating is not None:
            rating_ = self.rating
            rating_.to_etree(element, name_='rating', mapping_=mapping_)
        if self.user_rating is not None:
            user_rating_ = self.user_rating
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}user-rating').text = self.gds_format_integer(user_rating_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory()
            obj_.build(child_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'disambiguation':
            disambiguation_ = child_.text
            disambiguation_ = self.gds_validate_string(disambiguation_, node, 'disambiguation')
            self.disambiguation = disambiguation_
        elif nodeName_ == 'first-release-date':
            first_release_date_ = child_.text
            first_release_date_ = self.gds_validate_string(first_release_date_, node, 'first_release_date')
            self.first_release_date = first_release_date_
            # validate type def_incomplete-date
            self.validate_def_incomplete_date(self.first_release_date)
        elif nodeName_ == 'primary-type':
            obj_ = primary_type.factory()
            obj_.build(child_)
            self.primary_type = obj_
            obj_.original_tagname_ = 'primary-type'
        elif nodeName_ == 'secondary-type-list':
            obj_ = secondary_type_list.factory()
            obj_.build(child_)
            self.secondary_type_list = obj_
            obj_.original_tagname_ = 'secondary-type-list'
        elif nodeName_ == 'artist-credit':
            obj_ = artist_credit.factory()
            obj_.build(child_)
            self.artist_credit = obj_
            obj_.original_tagname_ = 'artist-credit'
        elif nodeName_ == 'release-list':
            obj_ = release_list.factory()
            obj_.build(child_)
            self.release_list = obj_
            obj_.original_tagname_ = 'release-list'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory()
            obj_.build(child_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory()
            obj_.build(child_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory()
            obj_.build(child_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory()
            obj_.build(child_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'rating':
            obj_ = rating.factory()
            obj_.build(child_)
            self.rating = obj_
            obj_.original_tagname_ = 'rating'
        elif nodeName_ == 'user-rating':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'user_rating')
            self.user_rating = ival_
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class release_group


class primary_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, primary_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if primary_type.subclass:
            return primary_type.subclass(*args_, **kwargs_)
        else:
            return primary_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='primary-type', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='primary-type')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='primary-type'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='primary-type', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='primary-type', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.id)
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class primary_type


class secondary_type_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, secondary_type=None):
        self.original_tagname_ = None
        if secondary_type is None:
            self.secondary_type = []
        else:
            self.secondary_type = secondary_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, secondary_type_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if secondary_type_list.subclass:
            return secondary_type_list.subclass(*args_, **kwargs_)
        else:
            return secondary_type_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_secondary_type(self): return self.secondary_type
    def set_secondary_type(self, secondary_type): self.secondary_type = secondary_type
    def add_secondary_type(self, value): self.secondary_type.append(value)
    def insert_secondary_type_at(self, index, value): self.secondary_type.insert(index, value)
    def replace_secondary_type_at(self, index, value): self.secondary_type[index] = value
    def hasContent_(self):
        if (
            self.secondary_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='secondary-type-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='secondary-type-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='secondary-type-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='secondary-type-list'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='secondary-type-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for secondary_type_ in self.secondary_type:
            secondary_type_.export(outfile, level, namespace_='mmd-2.0:', name_='secondary-type', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='secondary-type-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        for secondary_type_ in self.secondary_type:
            secondary_type_.to_etree(element, name_='secondary-type', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'secondary-type':
            obj_ = secondary_type.factory()
            obj_.build(child_)
            self.secondary_type.append(obj_)
            obj_.original_tagname_ = 'secondary-type'
# end class secondary_type_list


class secondary_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, secondary_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if secondary_type.subclass:
            return secondary_type.subclass(*args_, **kwargs_)
        else:
            return secondary_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='secondary-type', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='secondary-type')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='secondary-type'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='secondary-type', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='secondary-type', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.id)
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class secondary_type


class recording(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, title=None, length=None, annotation=None, disambiguation=None, video=None, artist_credit=None, release_list=None, alias_list=None, puid_list=None, isrc_list=None, relation_list=None, tag_list=None, user_tag_list=None, rating=None, user_rating=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.title = title
        self.length = length
        self.annotation = annotation
        self.disambiguation = disambiguation
        self.video = video
        self.validate_video(self.video)
        self.artist_credit = artist_credit
        self.release_list = release_list
        self.alias_list = alias_list
        self.puid_list = puid_list
        self.isrc_list = isrc_list
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.tag_list = tag_list
        self.user_tag_list = user_tag_list
        self.rating = rating
        self.user_rating = user_rating
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, recording)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if recording.subclass:
            return recording.subclass(*args_, **kwargs_)
        else:
            return recording(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def get_disambiguation(self): return self.disambiguation
    def set_disambiguation(self, disambiguation): self.disambiguation = disambiguation
    def get_video(self): return self.video
    def set_video(self, video): self.video = video
    def get_artist_credit(self): return self.artist_credit
    def set_artist_credit(self, artist_credit): self.artist_credit = artist_credit
    def get_release_list(self): return self.release_list
    def set_release_list(self, release_list): self.release_list = release_list
    def get_alias_list(self): return self.alias_list
    def set_alias_list(self, alias_list): self.alias_list = alias_list
    def get_puid_list(self): return self.puid_list
    def set_puid_list(self, puid_list): self.puid_list = puid_list
    def get_isrc_list(self): return self.isrc_list
    def set_isrc_list(self, isrc_list): self.isrc_list = isrc_list
    def get_relation_list(self): return self.relation_list
    def set_relation_list(self, relation_list): self.relation_list = relation_list
    def add_relation_list(self, value): self.relation_list.append(value)
    def insert_relation_list_at(self, index, value): self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value): self.relation_list[index] = value
    def get_tag_list(self): return self.tag_list
    def set_tag_list(self, tag_list): self.tag_list = tag_list
    def get_user_tag_list(self): return self.user_tag_list
    def set_user_tag_list(self, user_tag_list): self.user_tag_list = user_tag_list
    def get_rating(self): return self.rating
    def set_rating(self, rating): self.rating = rating
    def get_user_rating(self): return self.user_rating
    def set_user_rating(self, user_rating): self.user_rating = user_rating
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_video(self, value):
        # Validate type video, a restriction on xs:token.
        pass
    def hasContent_(self):
        if (
            self.title is not None or
            self.length is not None or
            self.annotation is not None or
            self.disambiguation is not None or
            self.video is not None or
            self.artist_credit is not None or
            self.release_list is not None or
            self.alias_list is not None or
            self.puid_list is not None or
            self.isrc_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.rating is not None or
            self.user_rating is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='recording', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recording')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='recording', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='recording'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='recording', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespace_, eol_))
        if self.length is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespace_, self.gds_format_integer(self.length, input_name='length'), namespace_, eol_))
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_='mmd-2.0:', name_='annotation', pretty_print=pretty_print)
        if self.disambiguation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespace_, eol_))
        if self.video is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svideo>%s</%svideo>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.video), input_name='video')), namespace_, eol_))
        if self.artist_credit is not None:
            self.artist_credit.export(outfile, level, namespace_='mmd-2.0:', name_='artist-credit', pretty_print=pretty_print)
        if self.release_list is not None:
            self.release_list.export(outfile, level, namespace_='mmd-2.0:', name_='release-list', pretty_print=pretty_print)
        if self.alias_list is not None:
            self.alias_list.export(outfile, level, namespace_='mmd-2.0:', name_='alias-list', pretty_print=pretty_print)
        if self.puid_list is not None:
            self.puid_list.export(outfile, level, namespace_='mmd-2.0:', name_='puid-list', pretty_print=pretty_print)
        if self.isrc_list is not None:
            self.isrc_list.export(outfile, level, namespace_='mmd-2.0:', name_='isrc-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            relation_list_.export(outfile, level, namespace_='mmd-2.0:', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            self.tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            self.user_tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='user-tag-list', pretty_print=pretty_print)
        if self.rating is not None:
            self.rating.export(outfile, level, namespace_='mmd-2.0:', name_='rating', pretty_print=pretty_print)
        if self.user_rating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-rating>%s</%suser-rating>%s' % (namespace_, self.gds_format_integer(self.user_rating, input_name='user-rating'), namespace_, eol_))
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='recording', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}length').text = self.gds_format_integer(length_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.video is not None:
            video_ = self.video
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}video').text = self.gds_format_string(video_)
        if self.artist_credit is not None:
            artist_credit_ = self.artist_credit
            artist_credit_.to_etree(element, name_='artist-credit', mapping_=mapping_)
        if self.release_list is not None:
            release_list_ = self.release_list
            release_list_.to_etree(element, name_='release-list', mapping_=mapping_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_)
        if self.puid_list is not None:
            puid_list_ = self.puid_list
            puid_list_.to_etree(element, name_='puid-list', mapping_=mapping_)
        if self.isrc_list is not None:
            isrc_list_ = self.isrc_list
            isrc_list_.to_etree(element, name_='isrc-list', mapping_=mapping_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_)
        if self.rating is not None:
            rating_ = self.rating
            rating_.to_etree(element, name_='rating', mapping_=mapping_)
        if self.user_rating is not None:
            user_rating_ = self.user_rating
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}user-rating').text = self.gds_format_integer(user_rating_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'length':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory()
            obj_.build(child_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'disambiguation':
            disambiguation_ = child_.text
            disambiguation_ = self.gds_validate_string(disambiguation_, node, 'disambiguation')
            self.disambiguation = disambiguation_
        elif nodeName_ == 'video':
            video_ = child_.text
            if video_:
                video_ = re_.sub(String_cleanup_pat_, " ", video_).strip()
            else:
                video_ = ""
            video_ = self.gds_validate_string(video_, node, 'video')
            self.video = video_
            # validate type video
            self.validate_video(self.video)
        elif nodeName_ == 'artist-credit':
            obj_ = artist_credit.factory()
            obj_.build(child_)
            self.artist_credit = obj_
            obj_.original_tagname_ = 'artist-credit'
        elif nodeName_ == 'release-list':
            obj_ = release_list.factory()
            obj_.build(child_)
            self.release_list = obj_
            obj_.original_tagname_ = 'release-list'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory()
            obj_.build(child_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'puid-list':
            obj_ = puid_list.factory()
            obj_.build(child_)
            self.puid_list = obj_
            obj_.original_tagname_ = 'puid-list'
        elif nodeName_ == 'isrc-list':
            obj_ = isrc_list.factory()
            obj_.build(child_)
            self.isrc_list = obj_
            obj_.original_tagname_ = 'isrc-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory()
            obj_.build(child_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory()
            obj_.build(child_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory()
            obj_.build(child_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'rating':
            obj_ = rating.factory()
            obj_.build(child_)
            self.rating = obj_
            obj_.original_tagname_ = 'rating'
        elif nodeName_ == 'user-rating':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'user_rating')
            self.user_rating = ival_
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class recording


class label(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, sort_name=None, label_code=None, ipi=None, ipi_list=None, annotation=None, disambiguation=None, country=None, area=None, life_span=None, alias_list=None, release_list=None, relation_list=None, tag_list=None, user_tag_list=None, rating=None, user_rating=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.name = name
        self.sort_name = sort_name
        self.label_code = label_code
        self.ipi = ipi
        self.validate_def_ipi(self.ipi)
        self.ipi_list = ipi_list
        self.annotation = annotation
        self.disambiguation = disambiguation
        self.country = country
        self.validate_def_iso_3166_1_code(self.country)
        self.area = area
        self.life_span = life_span
        self.alias_list = alias_list
        self.release_list = release_list
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.tag_list = tag_list
        self.user_tag_list = user_tag_list
        self.rating = rating
        self.user_rating = user_rating
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, label)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if label.subclass:
            return label.subclass(*args_, **kwargs_)
        else:
            return label(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_sort_name(self): return self.sort_name
    def set_sort_name(self, sort_name): self.sort_name = sort_name
    def get_label_code(self): return self.label_code
    def set_label_code(self, label_code): self.label_code = label_code
    def get_ipi(self): return self.ipi
    def set_ipi(self, ipi): self.ipi = ipi
    def get_ipi_list(self): return self.ipi_list
    def set_ipi_list(self, ipi_list): self.ipi_list = ipi_list
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def get_disambiguation(self): return self.disambiguation
    def set_disambiguation(self, disambiguation): self.disambiguation = disambiguation
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_area(self): return self.area
    def set_area(self, area): self.area = area
    def get_life_span(self): return self.life_span
    def set_life_span(self, life_span): self.life_span = life_span
    def get_alias_list(self): return self.alias_list
    def set_alias_list(self, alias_list): self.alias_list = alias_list
    def get_release_list(self): return self.release_list
    def set_release_list(self, release_list): self.release_list = release_list
    def get_relation_list(self): return self.relation_list
    def set_relation_list(self, relation_list): self.relation_list = relation_list
    def add_relation_list(self, value): self.relation_list.append(value)
    def insert_relation_list_at(self, index, value): self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value): self.relation_list[index] = value
    def get_tag_list(self): return self.tag_list
    def set_tag_list(self, tag_list): self.tag_list = tag_list
    def get_user_tag_list(self): return self.user_tag_list
    def set_user_tag_list(self, user_tag_list): self.user_tag_list = user_tag_list
    def get_rating(self): return self.rating
    def set_rating(self, rating): self.rating = rating
    def get_user_rating(self): return self.user_rating
    def set_user_rating(self, user_rating): self.user_rating = user_rating
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def validate_def_ipi(self, value):
        # Validate type def_ipi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_ipi_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_ipi_patterns_, ))
    validate_def_ipi_patterns_ = [['^[0-9]{11}$']]
    def validate_def_iso_3166_1_code(self, value):
        # Validate type def_iso-3166-1-code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_3166_1_code_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_iso_3166_1_code_patterns_, ))
    validate_def_iso_3166_1_code_patterns_ = [['^[A-Z]{2}$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.sort_name is not None or
            self.label_code is not None or
            self.ipi is not None or
            self.ipi_list is not None or
            self.annotation is not None or
            self.disambiguation is not None or
            self.country is not None or
            self.area is not None or
            self.life_span is not None or
            self.alias_list is not None or
            self.release_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.rating is not None or
            self.user_rating is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='label', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='label')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='label', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='label'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='label', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.sort_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssort-name>%s</%ssort-name>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.sort_name), input_name='sort-name')), namespace_, eol_))
        if self.label_code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slabel-code>%s</%slabel-code>%s' % (namespace_, self.gds_format_integer(self.label_code, input_name='label-code'), namespace_, eol_))
        if self.ipi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sipi>%s</%sipi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ipi), input_name='ipi')), namespace_, eol_))
        if self.ipi_list is not None:
            self.ipi_list.export(outfile, level, namespace_='mmd-2.0:', name_='ipi-list', pretty_print=pretty_print)
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_='mmd-2.0:', name_='annotation', pretty_print=pretty_print)
        if self.disambiguation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespace_, eol_))
        if self.country is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scountry>%s</%scountry>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.country), input_name='country')), namespace_, eol_))
        if self.area is not None:
            self.area.export(outfile, level, namespace_='mmd-2.0:', name_='area', pretty_print=pretty_print)
        if self.life_span is not None:
            self.life_span.export(outfile, level, namespace_='mmd-2.0:', name_='life-span', pretty_print=pretty_print)
        if self.alias_list is not None:
            self.alias_list.export(outfile, level, namespace_='mmd-2.0:', name_='alias-list', pretty_print=pretty_print)
        if self.release_list is not None:
            self.release_list.export(outfile, level, namespace_='mmd-2.0:', name_='release-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            relation_list_.export(outfile, level, namespace_='mmd-2.0:', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            self.tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            self.user_tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='user-tag-list', pretty_print=pretty_print)
        if self.rating is not None:
            self.rating.export(outfile, level, namespace_='mmd-2.0:', name_='rating', pretty_print=pretty_print)
        if self.user_rating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-rating>%s</%suser-rating>%s' % (namespace_, self.gds_format_integer(self.user_rating, input_name='user-rating'), namespace_, eol_))
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='label', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.sort_name is not None:
            sort_name_ = self.sort_name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}sort-name').text = self.gds_format_string(sort_name_)
        if self.label_code is not None:
            label_code_ = self.label_code
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}label-code').text = self.gds_format_integer(label_code_)
        if self.ipi is not None:
            ipi_ = self.ipi
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}ipi').text = self.gds_format_string(ipi_)
        if self.ipi_list is not None:
            ipi_list_ = self.ipi_list
            ipi_list_.to_etree(element, name_='ipi-list', mapping_=mapping_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.country is not None:
            country_ = self.country
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}country').text = self.gds_format_string(country_)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_)
        if self.life_span is not None:
            life_span_ = self.life_span
            life_span_.to_etree(element, name_='life-span', mapping_=mapping_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_)
        if self.release_list is not None:
            release_list_ = self.release_list
            release_list_.to_etree(element, name_='release-list', mapping_=mapping_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_)
        if self.rating is not None:
            rating_ = self.rating
            rating_.to_etree(element, name_='rating', mapping_=mapping_)
        if self.user_rating is not None:
            user_rating_ = self.user_rating
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}user-rating').text = self.gds_format_integer(user_rating_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'sort-name':
            sort_name_ = child_.text
            sort_name_ = self.gds_validate_string(sort_name_, node, 'sort_name')
            self.sort_name = sort_name_
        elif nodeName_ == 'label-code':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'label_code')
            self.label_code = ival_
        elif nodeName_ == 'ipi':
            ipi_ = child_.text
            ipi_ = self.gds_validate_string(ipi_, node, 'ipi')
            self.ipi = ipi_
            # validate type def_ipi
            self.validate_def_ipi(self.ipi)
        elif nodeName_ == 'ipi-list':
            obj_ = ipi_list.factory()
            obj_.build(child_)
            self.ipi_list = obj_
            obj_.original_tagname_ = 'ipi-list'
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory()
            obj_.build(child_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'disambiguation':
            disambiguation_ = child_.text
            disambiguation_ = self.gds_validate_string(disambiguation_, node, 'disambiguation')
            self.disambiguation = disambiguation_
        elif nodeName_ == 'country':
            country_ = child_.text
            country_ = self.gds_validate_string(country_, node, 'country')
            self.country = country_
            # validate type def_iso-3166-1-code
            self.validate_def_iso_3166_1_code(self.country)
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory()
            obj_.build(child_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'life-span':
            obj_ = life_span.factory()
            obj_.build(child_)
            self.life_span = obj_
            obj_.original_tagname_ = 'life-span'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory()
            obj_.build(child_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'release-list':
            obj_ = release_list.factory()
            obj_.build(child_)
            self.release_list = obj_
            obj_.original_tagname_ = 'release-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory()
            obj_.build(child_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory()
            obj_.build(child_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory()
            obj_.build(child_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'rating':
            obj_ = rating.factory()
            obj_.build(child_)
            self.rating = obj_
            obj_.original_tagname_ = 'rating'
        elif nodeName_ == 'user-rating':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'user_rating')
            self.user_rating = ival_
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class label


class work(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, title=None, language=None, language_list=None, artist_credit=None, iswc=None, iswc_list=None, attribute_list=None, annotation=None, disambiguation=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, rating=None, user_rating=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.title = title
        self.language = language
        self.validate_def_iso_639(self.language)
        self.language_list = language_list
        self.artist_credit = artist_credit
        self.iswc = iswc
        self.validate_iswc(self.iswc)
        self.iswc_list = iswc_list
        self.attribute_list = attribute_list
        self.annotation = annotation
        self.disambiguation = disambiguation
        self.alias_list = alias_list
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.tag_list = tag_list
        self.user_tag_list = user_tag_list
        self.rating = rating
        self.user_rating = user_rating
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, work)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if work.subclass:
            return work.subclass(*args_, **kwargs_)
        else:
            return work(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_language_list(self): return self.language_list
    def set_language_list(self, language_list): self.language_list = language_list
    def get_artist_credit(self): return self.artist_credit
    def set_artist_credit(self, artist_credit): self.artist_credit = artist_credit
    def get_iswc(self): return self.iswc
    def set_iswc(self, iswc): self.iswc = iswc
    def get_iswc_list(self): return self.iswc_list
    def set_iswc_list(self, iswc_list): self.iswc_list = iswc_list
    def get_attribute_list(self): return self.attribute_list
    def set_attribute_list(self, attribute_list): self.attribute_list = attribute_list
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def get_disambiguation(self): return self.disambiguation
    def set_disambiguation(self, disambiguation): self.disambiguation = disambiguation
    def get_alias_list(self): return self.alias_list
    def set_alias_list(self, alias_list): self.alias_list = alias_list
    def get_relation_list(self): return self.relation_list
    def set_relation_list(self, relation_list): self.relation_list = relation_list
    def add_relation_list(self, value): self.relation_list.append(value)
    def insert_relation_list_at(self, index, value): self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value): self.relation_list[index] = value
    def get_tag_list(self): return self.tag_list
    def set_tag_list(self, tag_list): self.tag_list = tag_list
    def get_user_tag_list(self): return self.user_tag_list
    def set_user_tag_list(self, user_tag_list): self.user_tag_list = user_tag_list
    def get_rating(self): return self.rating
    def set_rating(self, rating): self.rating = rating
    def get_user_rating(self): return self.user_rating
    def set_user_rating(self, user_rating): self.user_rating = user_rating
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def validate_def_iso_639(self, value):
        # Validate type def_iso-639, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_639_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_iso_639_patterns_, ))
    validate_def_iso_639_patterns_ = [['^[a-z]{3}$']]
    def validate_iswc(self, value):
        # Validate type iswc, a restriction on xs:token.
        pass
    def hasContent_(self):
        if (
            self.title is not None or
            self.language is not None or
            self.language_list is not None or
            self.artist_credit is not None or
            self.iswc is not None or
            self.iswc_list is not None or
            self.attribute_list is not None or
            self.annotation is not None or
            self.disambiguation is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.rating is not None or
            self.user_rating is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='work', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='work')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='work', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='work'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='work', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespace_, eol_))
        if self.language is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slanguage>%s</%slanguage>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.language), input_name='language')), namespace_, eol_))
        if self.language_list is not None:
            self.language_list.export(outfile, level, namespace_='mmd-2.0:', name_='language-list', pretty_print=pretty_print)
        if self.artist_credit is not None:
            self.artist_credit.export(outfile, level, namespace_='mmd-2.0:', name_='artist-credit', pretty_print=pretty_print)
        if self.iswc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%siswc>%s</%siswc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.iswc), input_name='iswc')), namespace_, eol_))
        if self.iswc_list is not None:
            self.iswc_list.export(outfile, level, namespace_='mmd-2.0:', name_='iswc-list', pretty_print=pretty_print)
        if self.attribute_list is not None:
            self.attribute_list.export(outfile, level, namespace_, name_='attribute-list', pretty_print=pretty_print)
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_='mmd-2.0:', name_='annotation', pretty_print=pretty_print)
        if self.disambiguation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespace_, eol_))
        if self.alias_list is not None:
            self.alias_list.export(outfile, level, namespace_='mmd-2.0:', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            relation_list_.export(outfile, level, namespace_='mmd-2.0:', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            self.tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            self.user_tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='user-tag-list', pretty_print=pretty_print)
        if self.rating is not None:
            self.rating.export(outfile, level, namespace_='mmd-2.0:', name_='rating', pretty_print=pretty_print)
        if self.user_rating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-rating>%s</%suser-rating>%s' % (namespace_, self.gds_format_integer(self.user_rating, input_name='user-rating'), namespace_, eol_))
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='work', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.language is not None:
            language_ = self.language
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}language').text = self.gds_format_string(language_)
        if self.language_list is not None:
            language_list_ = self.language_list
            language_list_.to_etree(element, name_='language-list', mapping_=mapping_)
        if self.artist_credit is not None:
            artist_credit_ = self.artist_credit
            artist_credit_.to_etree(element, name_='artist-credit', mapping_=mapping_)
        if self.iswc is not None:
            iswc_ = self.iswc
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}iswc').text = self.gds_format_string(iswc_)
        if self.iswc_list is not None:
            iswc_list_ = self.iswc_list
            iswc_list_.to_etree(element, name_='iswc-list', mapping_=mapping_)
        if self.attribute_list is not None:
            attribute_list_ = self.attribute_list
            attribute_list_.to_etree(element, name_='attribute-list', mapping_=mapping_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_)
        if self.rating is not None:
            rating_ = self.rating
            rating_.to_etree(element, name_='rating', mapping_=mapping_)
        if self.user_rating is not None:
            user_rating_ = self.user_rating
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}user-rating').text = self.gds_format_integer(user_rating_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'language':
            language_ = child_.text
            language_ = self.gds_validate_string(language_, node, 'language')
            self.language = language_
            # validate type def_iso-639
            self.validate_def_iso_639(self.language)
        elif nodeName_ == 'language-list':
            obj_ = language_list.factory()
            obj_.build(child_)
            self.language_list = obj_
            obj_.original_tagname_ = 'language-list'
        elif nodeName_ == 'artist-credit':
            obj_ = artist_credit.factory()
            obj_.build(child_)
            self.artist_credit = obj_
            obj_.original_tagname_ = 'artist-credit'
        elif nodeName_ == 'iswc':
            iswc_ = child_.text
            if iswc_:
                iswc_ = re_.sub(String_cleanup_pat_, " ", iswc_).strip()
            else:
                iswc_ = ""
            iswc_ = self.gds_validate_string(iswc_, node, 'iswc')
            self.iswc = iswc_
            # validate type iswc
            self.validate_iswc(self.iswc)
        elif nodeName_ == 'iswc-list':
            obj_ = iswc_list.factory()
            obj_.build(child_)
            self.iswc_list = obj_
            obj_.original_tagname_ = 'iswc-list'
        elif nodeName_ == 'attribute-list':
            obj_ = attribute_listType12.factory()
            obj_.build(child_)
            self.attribute_list = obj_
            obj_.original_tagname_ = 'attribute-list'
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory()
            obj_.build(child_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'disambiguation':
            disambiguation_ = child_.text
            disambiguation_ = self.gds_validate_string(disambiguation_, node, 'disambiguation')
            self.disambiguation = disambiguation_
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory()
            obj_.build(child_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory()
            obj_.build(child_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory()
            obj_.build(child_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory()
            obj_.build(child_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'rating':
            obj_ = rating.factory()
            obj_.build(child_)
            self.rating = obj_
            obj_.original_tagname_ = 'rating'
        elif nodeName_ == 'user-rating':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'user_rating')
            self.user_rating = ival_
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class work


class place(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, disambiguation=None, address=None, coordinates=None, annotation=None, area=None, life_span=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.name = name
        self.disambiguation = disambiguation
        self.address = address
        self.coordinates = coordinates
        self.annotation = annotation
        self.area = area
        self.life_span = life_span
        self.alias_list = alias_list
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.tag_list = tag_list
        self.user_tag_list = user_tag_list
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, place)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if place.subclass:
            return place.subclass(*args_, **kwargs_)
        else:
            return place(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_disambiguation(self): return self.disambiguation
    def set_disambiguation(self, disambiguation): self.disambiguation = disambiguation
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_coordinates(self): return self.coordinates
    def set_coordinates(self, coordinates): self.coordinates = coordinates
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def get_area(self): return self.area
    def set_area(self, area): self.area = area
    def get_life_span(self): return self.life_span
    def set_life_span(self, life_span): self.life_span = life_span
    def get_alias_list(self): return self.alias_list
    def set_alias_list(self, alias_list): self.alias_list = alias_list
    def get_relation_list(self): return self.relation_list
    def set_relation_list(self, relation_list): self.relation_list = relation_list
    def add_relation_list(self, value): self.relation_list.append(value)
    def insert_relation_list_at(self, index, value): self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value): self.relation_list[index] = value
    def get_tag_list(self): return self.tag_list
    def set_tag_list(self, tag_list): self.tag_list = tag_list
    def get_user_tag_list(self): return self.user_tag_list
    def set_user_tag_list(self, user_tag_list): self.user_tag_list = user_tag_list
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def hasContent_(self):
        if (
            self.name is not None or
            self.disambiguation is not None or
            self.address is not None or
            self.coordinates is not None or
            self.annotation is not None or
            self.area is not None or
            self.life_span is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='place', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='place')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='place', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='place'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='place', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.disambiguation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespace_, eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.address), input_name='address')), namespace_, eol_))
        if self.coordinates is not None:
            self.coordinates.export(outfile, level, namespace_='mmd-2.0:', name_='coordinates', pretty_print=pretty_print)
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_='mmd-2.0:', name_='annotation', pretty_print=pretty_print)
        if self.area is not None:
            self.area.export(outfile, level, namespace_='mmd-2.0:', name_='area', pretty_print=pretty_print)
        if self.life_span is not None:
            self.life_span.export(outfile, level, namespace_='mmd-2.0:', name_='life-span', pretty_print=pretty_print)
        if self.alias_list is not None:
            self.alias_list.export(outfile, level, namespace_='mmd-2.0:', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            relation_list_.export(outfile, level, namespace_='mmd-2.0:', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            self.tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            self.user_tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='user-tag-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='place', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.address is not None:
            address_ = self.address
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}address').text = self.gds_format_string(address_)
        if self.coordinates is not None:
            coordinates_ = self.coordinates
            coordinates_.to_etree(element, name_='coordinates', mapping_=mapping_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_)
        if self.life_span is not None:
            life_span_ = self.life_span
            life_span_.to_etree(element, name_='life-span', mapping_=mapping_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'disambiguation':
            disambiguation_ = child_.text
            disambiguation_ = self.gds_validate_string(disambiguation_, node, 'disambiguation')
            self.disambiguation = disambiguation_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'coordinates':
            obj_ = coordinates.factory()
            obj_.build(child_)
            self.coordinates = obj_
            obj_.original_tagname_ = 'coordinates'
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory()
            obj_.build(child_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory()
            obj_.build(child_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'life-span':
            obj_ = life_span.factory()
            obj_.build(child_)
            self.life_span = obj_
            obj_.original_tagname_ = 'life-span'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory()
            obj_.build(child_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory()
            obj_.build(child_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory()
            obj_.build(child_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory()
            obj_.build(child_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class place


class coordinates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, latitude=None, longitude=None):
        self.original_tagname_ = None
        self.latitude = latitude
        self.longitude = longitude
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, coordinates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if coordinates.subclass:
            return coordinates.subclass(*args_, **kwargs_)
        else:
            return coordinates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_latitude(self): return self.latitude
    def set_latitude(self, latitude): self.latitude = latitude
    def get_longitude(self): return self.longitude
    def set_longitude(self, longitude): self.longitude = longitude
    def hasContent_(self):
        if (
            self.latitude is not None or
            self.longitude is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='coordinates', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='coordinates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='coordinates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='coordinates'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='coordinates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.latitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatitude>%s</%slatitude>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.latitude), input_name='latitude')), namespace_, eol_))
        if self.longitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slongitude>%s</%slongitude>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.longitude), input_name='longitude')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='coordinates', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.latitude is not None:
            latitude_ = self.latitude
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}latitude').text = self.gds_format_string(latitude_)
        if self.longitude is not None:
            longitude_ = self.longitude
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}longitude').text = self.gds_format_string(longitude_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'latitude':
            latitude_ = child_.text
            latitude_ = self.gds_validate_string(latitude_, node, 'latitude')
            self.latitude = latitude_
        elif nodeName_ == 'longitude':
            longitude_ = child_.text
            longitude_ = self.gds_validate_string(longitude_, node, 'longitude')
            self.longitude = longitude_
# end class coordinates


class instrument(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, disambiguation=None, description=None, annotation=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.name = name
        self.disambiguation = disambiguation
        self.description = description
        self.annotation = annotation
        self.alias_list = alias_list
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.tag_list = tag_list
        self.user_tag_list = user_tag_list
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instrument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instrument.subclass:
            return instrument.subclass(*args_, **kwargs_)
        else:
            return instrument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_disambiguation(self): return self.disambiguation
    def set_disambiguation(self, disambiguation): self.disambiguation = disambiguation
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def get_alias_list(self): return self.alias_list
    def set_alias_list(self, alias_list): self.alias_list = alias_list
    def get_relation_list(self): return self.relation_list
    def set_relation_list(self, relation_list): self.relation_list = relation_list
    def add_relation_list(self, value): self.relation_list.append(value)
    def insert_relation_list_at(self, index, value): self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value): self.relation_list[index] = value
    def get_tag_list(self): return self.tag_list
    def set_tag_list(self, tag_list): self.tag_list = tag_list
    def get_user_tag_list(self): return self.user_tag_list
    def set_user_tag_list(self, user_tag_list): self.user_tag_list = user_tag_list
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def hasContent_(self):
        if (
            self.name is not None or
            self.disambiguation is not None or
            self.description is not None or
            self.annotation is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='instrument', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='instrument')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='instrument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='instrument'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='instrument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.disambiguation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespace_, eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespace_, eol_))
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_='mmd-2.0:', name_='annotation', pretty_print=pretty_print)
        if self.alias_list is not None:
            self.alias_list.export(outfile, level, namespace_='mmd-2.0:', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            relation_list_.export(outfile, level, namespace_='mmd-2.0:', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            self.tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            self.user_tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='user-tag-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='instrument', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.description is not None:
            description_ = self.description
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}description').text = self.gds_format_string(description_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'disambiguation':
            disambiguation_ = child_.text
            disambiguation_ = self.gds_validate_string(disambiguation_, node, 'disambiguation')
            self.disambiguation = disambiguation_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory()
            obj_.build(child_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory()
            obj_.build(child_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory()
            obj_.build(child_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory()
            obj_.build(child_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory()
            obj_.build(child_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class instrument


class series(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, disambiguation=None, ordering_attribute=None, annotation=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.name = name
        self.disambiguation = disambiguation
        self.ordering_attribute = ordering_attribute
        self.annotation = annotation
        self.alias_list = alias_list
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.tag_list = tag_list
        self.user_tag_list = user_tag_list
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, series)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if series.subclass:
            return series.subclass(*args_, **kwargs_)
        else:
            return series(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_disambiguation(self): return self.disambiguation
    def set_disambiguation(self, disambiguation): self.disambiguation = disambiguation
    def get_ordering_attribute(self): return self.ordering_attribute
    def set_ordering_attribute(self, ordering_attribute): self.ordering_attribute = ordering_attribute
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def get_alias_list(self): return self.alias_list
    def set_alias_list(self, alias_list): self.alias_list = alias_list
    def get_relation_list(self): return self.relation_list
    def set_relation_list(self, relation_list): self.relation_list = relation_list
    def add_relation_list(self, value): self.relation_list.append(value)
    def insert_relation_list_at(self, index, value): self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value): self.relation_list[index] = value
    def get_tag_list(self): return self.tag_list
    def set_tag_list(self, tag_list): self.tag_list = tag_list
    def get_user_tag_list(self): return self.user_tag_list
    def set_user_tag_list(self, user_tag_list): self.user_tag_list = user_tag_list
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def hasContent_(self):
        if (
            self.name is not None or
            self.disambiguation is not None or
            self.ordering_attribute is not None or
            self.annotation is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='series', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='series')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='series', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='series'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='series', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.disambiguation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespace_, eol_))
        if self.ordering_attribute is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sordering-attribute>%s</%sordering-attribute>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ordering_attribute), input_name='ordering-attribute')), namespace_, eol_))
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_='mmd-2.0:', name_='annotation', pretty_print=pretty_print)
        if self.alias_list is not None:
            self.alias_list.export(outfile, level, namespace_='mmd-2.0:', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            relation_list_.export(outfile, level, namespace_='mmd-2.0:', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            self.tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            self.user_tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='user-tag-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='series', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.ordering_attribute is not None:
            ordering_attribute_ = self.ordering_attribute
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}ordering-attribute').text = self.gds_format_string(ordering_attribute_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'disambiguation':
            disambiguation_ = child_.text
            disambiguation_ = self.gds_validate_string(disambiguation_, node, 'disambiguation')
            self.disambiguation = disambiguation_
        elif nodeName_ == 'ordering-attribute':
            ordering_attribute_ = child_.text
            ordering_attribute_ = self.gds_validate_string(ordering_attribute_, node, 'ordering_attribute')
            self.ordering_attribute = ordering_attribute_
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory()
            obj_.build(child_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory()
            obj_.build(child_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory()
            obj_.build(child_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory()
            obj_.build(child_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory()
            obj_.build(child_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class series


class event(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, name=None, disambiguation=None, cancelled=None, life_span=None, time=None, setlist=None, annotation=None, alias_list=None, relation_list=None, tag_list=None, user_tag_list=None, rating=None, user_rating=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.name = name
        self.disambiguation = disambiguation
        self.cancelled = cancelled
        self.validate_cancelled(self.cancelled)
        self.life_span = life_span
        self.time = time
        self.validate_def_time(self.time)
        self.setlist = setlist
        self.annotation = annotation
        self.alias_list = alias_list
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
        self.tag_list = tag_list
        self.user_tag_list = user_tag_list
        self.rating = rating
        self.user_rating = user_rating
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if event.subclass:
            return event.subclass(*args_, **kwargs_)
        else:
            return event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_disambiguation(self): return self.disambiguation
    def set_disambiguation(self, disambiguation): self.disambiguation = disambiguation
    def get_cancelled(self): return self.cancelled
    def set_cancelled(self, cancelled): self.cancelled = cancelled
    def get_life_span(self): return self.life_span
    def set_life_span(self, life_span): self.life_span = life_span
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_setlist(self): return self.setlist
    def set_setlist(self, setlist): self.setlist = setlist
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def get_alias_list(self): return self.alias_list
    def set_alias_list(self, alias_list): self.alias_list = alias_list
    def get_relation_list(self): return self.relation_list
    def set_relation_list(self, relation_list): self.relation_list = relation_list
    def add_relation_list(self, value): self.relation_list.append(value)
    def insert_relation_list_at(self, index, value): self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value): self.relation_list[index] = value
    def get_tag_list(self): return self.tag_list
    def set_tag_list(self, tag_list): self.tag_list = tag_list
    def get_user_tag_list(self): return self.user_tag_list
    def set_user_tag_list(self, user_tag_list): self.user_tag_list = user_tag_list
    def get_rating(self): return self.rating
    def set_rating(self, rating): self.rating = rating
    def get_user_rating(self): return self.user_rating
    def set_user_rating(self, user_rating): self.user_rating = user_rating
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def validate_cancelled(self, value):
        # Validate type cancelled, a restriction on xs:token.
        pass
    def validate_def_time(self, value):
        # Validate type def_time, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_time_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_time_patterns_, ))
    validate_def_time_patterns_ = [['^([01][0-9]$|^2[0-3]):[0-5][0-9]$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.disambiguation is not None or
            self.cancelled is not None or
            self.life_span is not None or
            self.time is not None or
            self.setlist is not None or
            self.annotation is not None or
            self.alias_list is not None or
            self.relation_list or
            self.tag_list is not None or
            self.user_tag_list is not None or
            self.rating is not None or
            self.user_rating is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='event', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='event')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='event', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='event'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='event', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.disambiguation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisambiguation>%s</%sdisambiguation>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.disambiguation), input_name='disambiguation')), namespace_, eol_))
        if self.cancelled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scancelled>%s</%scancelled>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.cancelled), input_name='cancelled')), namespace_, eol_))
        if self.life_span is not None:
            self.life_span.export(outfile, level, namespace_, name_='life-span', pretty_print=pretty_print)
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.time), input_name='time')), namespace_, eol_))
        if self.setlist is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetlist>%s</%ssetlist>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.setlist), input_name='setlist')), namespace_, eol_))
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_='mmd-2.0:', name_='annotation', pretty_print=pretty_print)
        if self.alias_list is not None:
            self.alias_list.export(outfile, level, namespace_='mmd-2.0:', name_='alias-list', pretty_print=pretty_print)
        for relation_list_ in self.relation_list:
            relation_list_.export(outfile, level, namespace_='mmd-2.0:', name_='relation-list', pretty_print=pretty_print)
        if self.tag_list is not None:
            self.tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='tag-list', pretty_print=pretty_print)
        if self.user_tag_list is not None:
            self.user_tag_list.export(outfile, level, namespace_='mmd-2.0:', name_='user-tag-list', pretty_print=pretty_print)
        if self.rating is not None:
            self.rating.export(outfile, level, namespace_='mmd-2.0:', name_='rating', pretty_print=pretty_print)
        if self.user_rating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser-rating>%s</%suser-rating>%s' % (namespace_, self.gds_format_integer(self.user_rating, input_name='user-rating'), namespace_, eol_))
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='event', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.disambiguation is not None:
            disambiguation_ = self.disambiguation
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}disambiguation').text = self.gds_format_string(disambiguation_)
        if self.cancelled is not None:
            cancelled_ = self.cancelled
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}cancelled').text = self.gds_format_string(cancelled_)
        if self.life_span is not None:
            life_span_ = self.life_span
            life_span_.to_etree(element, name_='life-span', mapping_=mapping_)
        if self.time is not None:
            time_ = self.time
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}time').text = self.gds_format_string(time_)
        if self.setlist is not None:
            setlist_ = self.setlist
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}setlist').text = self.gds_format_string(setlist_)
        if self.annotation is not None:
            annotation_ = self.annotation
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_)
        if self.alias_list is not None:
            alias_list_ = self.alias_list
            alias_list_.to_etree(element, name_='alias-list', mapping_=mapping_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_)
        if self.tag_list is not None:
            tag_list_ = self.tag_list
            tag_list_.to_etree(element, name_='tag-list', mapping_=mapping_)
        if self.user_tag_list is not None:
            user_tag_list_ = self.user_tag_list
            user_tag_list_.to_etree(element, name_='user-tag-list', mapping_=mapping_)
        if self.rating is not None:
            rating_ = self.rating
            rating_.to_etree(element, name_='rating', mapping_=mapping_)
        if self.user_rating is not None:
            user_rating_ = self.user_rating
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}user-rating').text = self.gds_format_integer(user_rating_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'disambiguation':
            disambiguation_ = child_.text
            disambiguation_ = self.gds_validate_string(disambiguation_, node, 'disambiguation')
            self.disambiguation = disambiguation_
        elif nodeName_ == 'cancelled':
            cancelled_ = child_.text
            if cancelled_:
                cancelled_ = re_.sub(String_cleanup_pat_, " ", cancelled_).strip()
            else:
                cancelled_ = ""
            cancelled_ = self.gds_validate_string(cancelled_, node, 'cancelled')
            self.cancelled = cancelled_
            # validate type cancelled
            self.validate_cancelled(self.cancelled)
        elif nodeName_ == 'life-span':
            obj_ = life_spanType14.factory()
            obj_.build(child_)
            self.life_span = obj_
            obj_.original_tagname_ = 'life-span'
        elif nodeName_ == 'time':
            time_ = child_.text
            time_ = self.gds_validate_string(time_, node, 'time')
            self.time = time_
            # validate type def_time
            self.validate_def_time(self.time)
        elif nodeName_ == 'setlist':
            setlist_ = child_.text
            setlist_ = self.gds_validate_string(setlist_, node, 'setlist')
            self.setlist = setlist_
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory()
            obj_.build(child_)
            self.annotation = obj_
            obj_.original_tagname_ = 'annotation'
        elif nodeName_ == 'alias-list':
            obj_ = alias_list.factory()
            obj_.build(child_)
            self.alias_list = obj_
            obj_.original_tagname_ = 'alias-list'
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory()
            obj_.build(child_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
        elif nodeName_ == 'tag-list':
            obj_ = tag_list.factory()
            obj_.build(child_)
            self.tag_list = obj_
            obj_.original_tagname_ = 'tag-list'
        elif nodeName_ == 'user-tag-list':
            obj_ = user_tag_list.factory()
            obj_.build(child_)
            self.user_tag_list = obj_
            obj_.original_tagname_ = 'user-tag-list'
        elif nodeName_ == 'rating':
            obj_ = rating.factory()
            obj_.build(child_)
            self.rating = obj_
            obj_.original_tagname_ = 'rating'
        elif nodeName_ == 'user-rating':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'user_rating')
            self.user_rating = ival_
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class event


class url(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, resource=None, relation_list=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.resource = resource
        if relation_list is None:
            self.relation_list = []
        else:
            self.relation_list = relation_list
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, url)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if url.subclass:
            return url.subclass(*args_, **kwargs_)
        else:
            return url(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resource(self): return self.resource
    def set_resource(self, resource): self.resource = resource
    def get_relation_list(self): return self.relation_list
    def set_relation_list(self, relation_list): self.relation_list = relation_list
    def add_relation_list(self, value): self.relation_list.append(value)
    def insert_relation_list_at(self, index, value): self.relation_list.insert(index, value)
    def replace_relation_list_at(self, index, value): self.relation_list[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.resource is not None or
            self.relation_list
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='url', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='url')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='url', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='url'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='url', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresource>%s</%sresource>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.resource), input_name='resource')), namespace_, eol_))
        for relation_list_ in self.relation_list:
            relation_list_.export(outfile, level, namespace_='mmd-2.0:', name_='relation-list', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='url', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.resource is not None:
            resource_ = self.resource
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}resource').text = self.gds_format_string(resource_)
        for relation_list_ in self.relation_list:
            relation_list_.to_etree(element, name_='relation-list', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resource':
            resource_ = child_.text
            resource_ = self.gds_validate_string(resource_, node, 'resource')
            self.resource = resource_
        elif nodeName_ == 'relation-list':
            obj_ = relation_list.factory()
            obj_.build(child_)
            self.relation_list.append(obj_)
            obj_.original_tagname_ = 'relation-list'
# end class url


class disc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, sectors=None, offset_list=None, release_list=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.sectors = sectors
        self.offset_list = offset_list
        self.release_list = release_list
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, disc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if disc.subclass:
            return disc.subclass(*args_, **kwargs_)
        else:
            return disc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sectors(self): return self.sectors
    def set_sectors(self, sectors): self.sectors = sectors
    def get_offset_list(self): return self.offset_list
    def set_offset_list(self, offset_list): self.offset_list = offset_list
    def get_release_list(self): return self.release_list
    def set_release_list(self, release_list): self.release_list = release_list
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.sectors is not None or
            self.offset_list is not None or
            self.release_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='disc', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='disc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='disc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='disc'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='disc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sectors is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssectors>%s</%ssectors>%s' % (namespace_, self.gds_format_integer(self.sectors, input_name='sectors'), namespace_, eol_))
        if self.offset_list is not None:
            self.offset_list.export(outfile, level, namespace_='mmd-2.0:', name_='offset-list', pretty_print=pretty_print)
        if self.release_list is not None:
            self.release_list.export(outfile, level, namespace_='mmd-2.0:', name_='release-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='disc', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.sectors is not None:
            sectors_ = self.sectors
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}sectors').text = self.gds_format_integer(sectors_)
        if self.offset_list is not None:
            offset_list_ = self.offset_list
            offset_list_.to_etree(element, name_='offset-list', mapping_=mapping_)
        if self.release_list is not None:
            release_list_ = self.release_list
            release_list_.to_etree(element, name_='release-list', mapping_=mapping_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sectors':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sectors')
            self.sectors = ival_
        elif nodeName_ == 'offset-list':
            obj_ = offset_list.factory()
            obj_.build(child_)
            self.offset_list = obj_
            obj_.original_tagname_ = 'offset-list'
        elif nodeName_ == 'release-list':
            obj_ = release_list.factory()
            obj_.build(child_)
            self.release_list = obj_
            obj_.original_tagname_ = 'release-list'
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class disc


class puid(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, recording_list=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.recording_list = recording_list
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, puid)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if puid.subclass:
            return puid.subclass(*args_, **kwargs_)
        else:
            return puid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_recording_list(self): return self.recording_list
    def set_recording_list(self, recording_list): self.recording_list = recording_list
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.recording_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='puid', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='puid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='puid', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='puid'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='puid', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.recording_list is not None:
            self.recording_list.export(outfile, level, namespace_='mmd-2.0:', name_='recording-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='puid', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.id)
        if self.recording_list is not None:
            recording_list_ = self.recording_list
            recording_list_.to_etree(element, name_='recording-list', mapping_=mapping_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'recording-list':
            obj_ = recording_list.factory()
            obj_.build(child_)
            self.recording_list = obj_
            obj_.original_tagname_ = 'recording-list'
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class puid


class isrc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, recording_list=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.recording_list = recording_list
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, isrc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if isrc.subclass:
            return isrc.subclass(*args_, **kwargs_)
        else:
            return isrc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_recording_list(self): return self.recording_list
    def set_recording_list(self, recording_list): self.recording_list = recording_list
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.recording_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='isrc', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isrc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='isrc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='isrc'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='isrc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.recording_list is not None:
            self.recording_list.export(outfile, level, namespace_='mmd-2.0:', name_='recording-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='isrc', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.id)
        if self.recording_list is not None:
            recording_list_ = self.recording_list
            recording_list_.to_etree(element, name_='recording-list', mapping_=mapping_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'recording-list':
            obj_ = recording_list.factory()
            obj_.build(child_)
            self.recording_list = obj_
            obj_.original_tagname_ = 'recording-list'
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class isrc


class artist_credit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name_credit=None):
        self.original_tagname_ = None
        if name_credit is None:
            self.name_credit = []
        else:
            self.name_credit = name_credit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, artist_credit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if artist_credit.subclass:
            return artist_credit.subclass(*args_, **kwargs_)
        else:
            return artist_credit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name_credit(self): return self.name_credit
    def set_name_credit(self, name_credit): self.name_credit = name_credit
    def add_name_credit(self, value): self.name_credit.append(value)
    def insert_name_credit_at(self, index, value): self.name_credit.insert(index, value)
    def replace_name_credit_at(self, index, value): self.name_credit[index] = value
    def hasContent_(self):
        if (
            self.name_credit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='artist-credit', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='artist-credit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='artist-credit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='artist-credit'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='artist-credit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for name_credit_ in self.name_credit:
            name_credit_.export(outfile, level, namespace_='mmd-2.0:', name_='name-credit', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='artist-credit', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        for name_credit_ in self.name_credit:
            name_credit_.to_etree(element, name_='name-credit', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name-credit':
            obj_ = name_credit.factory()
            obj_.build(child_)
            self.name_credit.append(obj_)
            obj_.original_tagname_ = 'name-credit'
# end class artist_credit


class name_credit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, joinphrase=None, name=None, artist=None):
        self.original_tagname_ = None
        self.joinphrase = _cast(None, joinphrase)
        self.name = name
        self.artist = artist
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, name_credit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if name_credit.subclass:
            return name_credit.subclass(*args_, **kwargs_)
        else:
            return name_credit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_artist(self): return self.artist
    def set_artist(self, artist): self.artist = artist
    def get_joinphrase(self): return self.joinphrase
    def set_joinphrase(self, joinphrase): self.joinphrase = joinphrase
    def hasContent_(self):
        if (
            self.name is not None or
            self.artist is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='name-credit', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='name-credit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='name-credit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='name-credit'):
        if self.joinphrase is not None and 'joinphrase' not in already_processed:
            already_processed.add('joinphrase')
            outfile.write(' joinphrase=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.joinphrase), input_name='joinphrase')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='name-credit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.artist is not None:
            self.artist.export(outfile, level, namespace_='mmd-2.0:', name_='artist', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='name-credit', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.joinphrase is not None:
            element.set('joinphrase', self.gds_format_string(self.joinphrase))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.artist is not None:
            artist_ = self.artist
            artist_.to_etree(element, name_='artist', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('joinphrase', node)
        if value is not None and 'joinphrase' not in already_processed:
            already_processed.add('joinphrase')
            self.joinphrase = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'artist':
            obj_ = artist.factory()
            obj_.build(child_)
            self.artist = obj_
            obj_.original_tagname_ = 'artist'
# end class name_credit


class relation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, type_id=None, target=None, ordering_key=None, direction=None, attribute_list=None, begin=None, end=None, ended=None, artist=None, release=None, release_group=None, recording=None, label=None, work=None, area=None, place=None, instrument=None, series=None, event=None, def_extension_element=None, source_credit=None, target_credit=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.target = target
        self.ordering_key = ordering_key
        self.direction = direction
        self.validate_def_direction(self.direction)
        self.attribute_list = attribute_list
        self.begin = begin
        self.validate_def_incomplete_date(self.begin)
        self.end = end
        self.validate_def_incomplete_date(self.end)
        self.ended = ended
        self.validate_ended(self.ended)
        self.artist = artist
        self.release = release
        self.release_group = release_group
        self.recording = recording
        self.label = label
        self.work = work
        self.area = area
        self.place = place
        self.instrument = instrument
        self.series = series
        self.event = event
        self.def_extension_element = def_extension_element
        self.source_credit = source_credit
        self.target_credit = target_credit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, relation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if relation.subclass:
            return relation.subclass(*args_, **kwargs_)
        else:
            return relation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def get_ordering_key(self): return self.ordering_key
    def set_ordering_key(self, ordering_key): self.ordering_key = ordering_key
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_attribute_list(self): return self.attribute_list
    def set_attribute_list(self, attribute_list): self.attribute_list = attribute_list
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_ended(self): return self.ended
    def set_ended(self, ended): self.ended = ended
    def get_artist(self): return self.artist
    def set_artist(self, artist): self.artist = artist
    def get_release(self): return self.release
    def set_release(self, release): self.release = release
    def get_release_group(self): return self.release_group
    def set_release_group(self, release_group): self.release_group = release_group
    def get_recording(self): return self.recording
    def set_recording(self, recording): self.recording = recording
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_work(self): return self.work
    def set_work(self, work): self.work = work
    def get_area(self): return self.area
    def set_area(self, area): self.area = area
    def get_place(self): return self.place
    def set_place(self, place): self.place = place
    def get_instrument(self): return self.instrument
    def set_instrument(self, instrument): self.instrument = instrument
    def get_series(self): return self.series
    def set_series(self, series): self.series = series
    def get_event(self): return self.event
    def set_event(self, event): self.event = event
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def get_source_credit(self): return self.source_credit
    def set_source_credit(self, source_credit): self.source_credit = source_credit
    def get_target_credit(self): return self.target_credit
    def set_target_credit(self, target_credit): self.target_credit = target_credit
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def validate_def_direction(self, value):
        # Validate type def_direction, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['both', 'forward', 'backward']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on def_direction' % {"value" : value.encode("utf-8")} )
    def validate_def_incomplete_date(self, value):
        # Validate type def_incomplete-date, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_incomplete_date_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_incomplete_date_patterns_, ))
    validate_def_incomplete_date_patterns_ = [['^[0-9]{4}(-[0-9]{2})?(-[0-9]{2})?$']]
    def validate_ended(self, value):
        # Validate type ended, a restriction on xs:token.
        pass
    def hasContent_(self):
        if (
            self.target is not None or
            self.ordering_key is not None or
            self.direction is not None or
            self.attribute_list is not None or
            self.begin is not None or
            self.end is not None or
            self.ended is not None or
            self.artist is not None or
            self.release is not None or
            self.release_group is not None or
            self.recording is not None or
            self.label is not None or
            self.work is not None or
            self.area is not None or
            self.place is not None or
            self.instrument is not None or
            self.series is not None or
            self.event is not None or
            self.def_extension_element is not None or
            self.source_credit is not None or
            self.target_credit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='relation', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='relation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='relation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='relation'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='relation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.target is not None:
            self.target.export(outfile, level, namespace_='mmd-2.0:', name_='target', pretty_print=pretty_print)
        if self.ordering_key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sordering-key>%s</%sordering-key>%s' % (namespace_, self.gds_format_integer(self.ordering_key, input_name='ordering-key'), namespace_, eol_))
        if self.direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirection>%s</%sdirection>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.direction), input_name='direction')), namespace_, eol_))
        if self.attribute_list is not None:
            self.attribute_list.export(outfile, level, namespace_, name_='attribute-list', pretty_print=pretty_print)
        if self.begin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbegin>%s</%sbegin>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.begin), input_name='begin')), namespace_, eol_))
        if self.end is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%send>%s</%send>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.end), input_name='end')), namespace_, eol_))
        if self.ended is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sended>%s</%sended>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.ended), input_name='ended')), namespace_, eol_))
        if self.artist is not None:
            self.artist.export(outfile, level, namespace_='mmd-2.0:', name_='artist', pretty_print=pretty_print)
        if self.release is not None:
            self.release.export(outfile, level, namespace_='mmd-2.0:', name_='release', pretty_print=pretty_print)
        if self.release_group is not None:
            self.release_group.export(outfile, level, namespace_='mmd-2.0:', name_='release-group', pretty_print=pretty_print)
        if self.recording is not None:
            self.recording.export(outfile, level, namespace_='mmd-2.0:', name_='recording', pretty_print=pretty_print)
        if self.label is not None:
            self.label.export(outfile, level, namespace_='mmd-2.0:', name_='label', pretty_print=pretty_print)
        if self.work is not None:
            self.work.export(outfile, level, namespace_='mmd-2.0:', name_='work', pretty_print=pretty_print)
        if self.area is not None:
            self.area.export(outfile, level, namespace_='mmd-2.0:', name_='area', pretty_print=pretty_print)
        if self.place is not None:
            self.place.export(outfile, level, namespace_='mmd-2.0:', name_='place', pretty_print=pretty_print)
        if self.instrument is not None:
            self.instrument.export(outfile, level, namespace_='mmd-2.0:', name_='instrument', pretty_print=pretty_print)
        if self.series is not None:
            self.series.export(outfile, level, namespace_='mmd-2.0:', name_='series', pretty_print=pretty_print)
        if self.event is not None:
            self.event.export(outfile, level, namespace_='mmd-2.0:', name_='event', pretty_print=pretty_print)
        if self.def_extension_element is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.def_extension_element), input_name='def_extension_element')), 'mmd-2.0:', eol_))
        if self.source_credit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource-credit>%s</%ssource-credit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.source_credit), input_name='source-credit')), namespace_, eol_))
        if self.target_credit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%starget-credit>%s</%starget-credit>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.target_credit), input_name='target-credit')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='relation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.target is not None:
            target_ = self.target
            target_.to_etree(element, name_='target', mapping_=mapping_)
        if self.ordering_key is not None:
            ordering_key_ = self.ordering_key
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}ordering-key').text = self.gds_format_integer(ordering_key_)
        if self.direction is not None:
            direction_ = self.direction
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}direction').text = self.gds_format_string(direction_)
        if self.attribute_list is not None:
            attribute_list_ = self.attribute_list
            attribute_list_.to_etree(element, name_='attribute-list', mapping_=mapping_)
        if self.begin is not None:
            begin_ = self.begin
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}begin').text = self.gds_format_string(begin_)
        if self.end is not None:
            end_ = self.end
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}end').text = self.gds_format_string(end_)
        if self.ended is not None:
            ended_ = self.ended
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}ended').text = self.gds_format_string(ended_)
        if self.artist is not None:
            artist_ = self.artist
            artist_.to_etree(element, name_='artist', mapping_=mapping_)
        if self.release is not None:
            release_ = self.release
            release_.to_etree(element, name_='release', mapping_=mapping_)
        if self.release_group is not None:
            release_group_ = self.release_group
            release_group_.to_etree(element, name_='release-group', mapping_=mapping_)
        if self.recording is not None:
            recording_ = self.recording
            recording_.to_etree(element, name_='recording', mapping_=mapping_)
        if self.label is not None:
            label_ = self.label
            label_.to_etree(element, name_='label', mapping_=mapping_)
        if self.work is not None:
            work_ = self.work
            work_.to_etree(element, name_='work', mapping_=mapping_)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_)
        if self.place is not None:
            place_ = self.place
            place_.to_etree(element, name_='place', mapping_=mapping_)
        if self.instrument is not None:
            instrument_ = self.instrument
            instrument_.to_etree(element, name_='instrument', mapping_=mapping_)
        if self.series is not None:
            series_ = self.series
            series_.to_etree(element, name_='series', mapping_=mapping_)
        if self.event is not None:
            event_ = self.event
            event_.to_etree(element, name_='event', mapping_=mapping_)
        if self.def_extension_element is not None:
            def_extension_element_ = self.def_extension_element
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if self.source_credit is not None:
            source_credit_ = self.source_credit
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}source-credit').text = self.gds_format_string(source_credit_)
        if self.target_credit is not None:
            target_credit_ = self.target_credit
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}target-credit').text = self.gds_format_string(target_credit_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'target':
            obj_ = target.factory()
            obj_.build(child_)
            self.target = obj_
            obj_.original_tagname_ = 'target'
        elif nodeName_ == 'ordering-key':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ordering_key')
            self.ordering_key = ival_
        elif nodeName_ == 'direction':
            direction_ = child_.text
            if direction_:
                direction_ = re_.sub(String_cleanup_pat_, " ", direction_).strip()
            else:
                direction_ = ""
            direction_ = self.gds_validate_string(direction_, node, 'direction')
            self.direction = direction_
            # validate type def_direction
            self.validate_def_direction(self.direction)
        elif nodeName_ == 'attribute-list':
            obj_ = attribute_listType15.factory()
            obj_.build(child_)
            self.attribute_list = obj_
            obj_.original_tagname_ = 'attribute-list'
        elif nodeName_ == 'begin':
            begin_ = child_.text
            begin_ = self.gds_validate_string(begin_, node, 'begin')
            self.begin = begin_
            # validate type def_incomplete-date
            self.validate_def_incomplete_date(self.begin)
        elif nodeName_ == 'end':
            end_ = child_.text
            end_ = self.gds_validate_string(end_, node, 'end')
            self.end = end_
            # validate type def_incomplete-date
            self.validate_def_incomplete_date(self.end)
        elif nodeName_ == 'ended':
            ended_ = child_.text
            if ended_:
                ended_ = re_.sub(String_cleanup_pat_, " ", ended_).strip()
            else:
                ended_ = ""
            ended_ = self.gds_validate_string(ended_, node, 'ended')
            self.ended = ended_
            # validate type ended
            self.validate_ended(self.ended)
        elif nodeName_ == 'artist':
            obj_ = artist.factory()
            obj_.build(child_)
            self.artist = obj_
            obj_.original_tagname_ = 'artist'
        elif nodeName_ == 'release':
            obj_ = release.factory()
            obj_.build(child_)
            self.release = obj_
            obj_.original_tagname_ = 'release'
        elif nodeName_ == 'release-group':
            obj_ = release_group.factory()
            obj_.build(child_)
            self.release_group = obj_
            obj_.original_tagname_ = 'release-group'
        elif nodeName_ == 'recording':
            obj_ = recording.factory()
            obj_.build(child_)
            self.recording = obj_
            obj_.original_tagname_ = 'recording'
        elif nodeName_ == 'label':
            obj_ = label.factory()
            obj_.build(child_)
            self.label = obj_
            obj_.original_tagname_ = 'label'
        elif nodeName_ == 'work':
            obj_ = work.factory()
            obj_.build(child_)
            self.work = obj_
            obj_.original_tagname_ = 'work'
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory()
            obj_.build(child_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'place':
            obj_ = place.factory()
            obj_.build(child_)
            self.place = obj_
            obj_.original_tagname_ = 'place'
        elif nodeName_ == 'instrument':
            obj_ = instrument.factory()
            obj_.build(child_)
            self.instrument = obj_
            obj_.original_tagname_ = 'instrument'
        elif nodeName_ == 'series':
            obj_ = series.factory()
            obj_.build(child_)
            self.series = obj_
            obj_.original_tagname_ = 'series'
        elif nodeName_ == 'event':
            obj_ = event.factory()
            obj_.build(child_)
            self.event = obj_
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element = def_extension_element_
        elif nodeName_ == 'source-credit':
            source_credit_ = child_.text
            source_credit_ = self.gds_validate_string(source_credit_, node, 'source_credit')
            self.source_credit = source_credit_
        elif nodeName_ == 'target-credit':
            target_credit_ = child_.text
            target_credit_ = self.gds_validate_string(target_credit_, node, 'target_credit')
            self.target_credit = target_credit_
# end class relation


class target(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, target)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if target.subclass:
            return target.subclass(*args_, **kwargs_)
        else:
            return target(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='target', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='target')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='target', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='target'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='target', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='target', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class target


class alias(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, locale=None, sort_name=None, type_=None, type_id=None, primary=None, begin_date=None, end_date=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.locale = _cast(None, locale)
        self.sort_name = _cast(None, sort_name)
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.primary = _cast(None, primary)
        self.begin_date = _cast(None, begin_date)
        self.end_date = _cast(None, end_date)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alias)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alias.subclass:
            return alias.subclass(*args_, **kwargs_)
        else:
            return alias(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_locale(self): return self.locale
    def set_locale(self, locale): self.locale = locale
    def get_sort_name(self): return self.sort_name
    def set_sort_name(self, sort_name): self.sort_name = sort_name
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def get_primary(self): return self.primary
    def set_primary(self, primary): self.primary = primary
    def get_begin_date(self): return self.begin_date
    def set_begin_date(self, begin_date): self.begin_date = begin_date
    def get_end_date(self): return self.end_date
    def set_end_date(self, end_date): self.end_date = end_date
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='alias', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alias')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='alias'):
        if self.locale is not None and 'locale' not in already_processed:
            already_processed.add('locale')
            outfile.write(' locale=%s' % (quote_attrib(self.locale), ))
        if self.sort_name is not None and 'sort_name' not in already_processed:
            already_processed.add('sort_name')
            outfile.write(' sort-name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sort_name), input_name='sort-name')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
        if self.primary is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            outfile.write(' primary=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.primary), input_name='primary')), ))
        if self.begin_date is not None and 'begin_date' not in already_processed:
            already_processed.add('begin_date')
            outfile.write(' begin-date=%s' % (quote_attrib(self.begin_date), ))
        if self.end_date is not None and 'end_date' not in already_processed:
            already_processed.add('end_date')
            outfile.write(' end-date=%s' % (quote_attrib(self.end_date), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='alias', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='alias', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.locale is not None:
            element.set('locale', self.locale)
        if self.sort_name is not None:
            element.set('sort-name', self.gds_format_string(self.sort_name))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.primary is not None:
            element.set('primary', self.gds_format_string(self.primary))
        if self.begin_date is not None:
            element.set('begin-date', self.begin_date)
        if self.end_date is not None:
            element.set('end-date', self.end_date)
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('locale', node)
        if value is not None and 'locale' not in already_processed:
            already_processed.add('locale')
            self.locale = value
        value = find_attr_value_('sort-name', node)
        if value is not None and 'sort-name' not in already_processed:
            already_processed.add('sort-name')
            self.sort_name = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
        value = find_attr_value_('primary', node)
        if value is not None and 'primary' not in already_processed:
            already_processed.add('primary')
            self.primary = value
        value = find_attr_value_('begin-date', node)
        if value is not None and 'begin-date' not in already_processed:
            already_processed.add('begin-date')
            self.begin_date = value
        value = find_attr_value_('end-date', node)
        if value is not None and 'end-date' not in already_processed:
            already_processed.add('end-date')
            self.end_date = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class alias


class iswc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, iswc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if iswc.subclass:
            return iswc.subclass(*args_, **kwargs_)
        else:
            return iswc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='iswc', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='iswc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='iswc', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='iswc'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='iswc', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='iswc', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class iswc


class tag(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, name=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tag)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tag.subclass:
            return tag.subclass(*args_, **kwargs_)
        else:
            return tag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='tag', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='tag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='tag'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='tag', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), 'mmd-2.0:', eol_))
    def to_etree(self, parent_element=None, name_='tag', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
# end class tag


class user_tag(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, user_tag)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if user_tag.subclass:
            return user_tag.subclass(*args_, **kwargs_)
        else:
            return user_tag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='user-tag', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='user-tag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='user-tag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='user-tag'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='user-tag', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), 'mmd-2.0:', eol_))
    def to_etree(self, parent_element=None, name_='user-tag', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
# end class user_tag


class rating(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, votes_count=None, valueOf_=None):
        self.original_tagname_ = None
        self.votes_count = _cast(int, votes_count)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rating)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rating.subclass:
            return rating.subclass(*args_, **kwargs_)
        else:
            return rating(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_votes_count(self): return self.votes_count
    def set_votes_count(self, votes_count): self.votes_count = votes_count
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='rating', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rating')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='rating', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='rating'):
        if self.votes_count is not None and 'votes_count' not in already_processed:
            already_processed.add('votes_count')
            outfile.write(' votes-count="%s"' % self.gds_format_integer(self.votes_count, input_name='votes-count'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='rating', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='rating', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.votes_count is not None:
            element.set('votes-count', self.gds_format_integer(self.votes_count))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('votes-count', node)
        if value is not None and 'votes-count' not in already_processed:
            already_processed.add('votes-count')
            try:
                self.votes_count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.votes_count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class rating


class label_info(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, catalog_number=None, label=None):
        self.original_tagname_ = None
        self.catalog_number = catalog_number
        self.label = label
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, label_info)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if label_info.subclass:
            return label_info.subclass(*args_, **kwargs_)
        else:
            return label_info(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_catalog_number(self): return self.catalog_number
    def set_catalog_number(self, catalog_number): self.catalog_number = catalog_number
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def hasContent_(self):
        if (
            self.catalog_number is not None or
            self.label is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='label-info', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='label-info')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='label-info', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='label-info'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='label-info', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.catalog_number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scatalog-number>%s</%scatalog-number>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.catalog_number), input_name='catalog-number')), namespace_, eol_))
        if self.label is not None:
            self.label.export(outfile, level, namespace_='mmd-2.0:', name_='label', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='label-info', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.catalog_number is not None:
            catalog_number_ = self.catalog_number
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}catalog-number').text = self.gds_format_string(catalog_number_)
        if self.label is not None:
            label_ = self.label
            label_.to_etree(element, name_='label', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'catalog-number':
            catalog_number_ = child_.text
            catalog_number_ = self.gds_validate_string(catalog_number_, node, 'catalog_number')
            self.catalog_number = catalog_number_
        elif nodeName_ == 'label':
            obj_ = label.factory()
            obj_.build(child_)
            self.label = obj_
            obj_.original_tagname_ = 'label'
# end class label_info


class medium(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, title=None, position=None, format=None, disc_list=None, pregap=None, track_list=None, data_track_list=None):
        self.original_tagname_ = None
        self.title = title
        self.position = position
        self.format = format
        self.disc_list = disc_list
        self.pregap = pregap
        self.track_list = track_list
        self.data_track_list = data_track_list
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, medium)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if medium.subclass:
            return medium.subclass(*args_, **kwargs_)
        else:
            return medium(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_disc_list(self): return self.disc_list
    def set_disc_list(self, disc_list): self.disc_list = disc_list
    def get_pregap(self): return self.pregap
    def set_pregap(self, pregap): self.pregap = pregap
    def get_track_list(self): return self.track_list
    def set_track_list(self, track_list): self.track_list = track_list
    def get_data_track_list(self): return self.data_track_list
    def set_data_track_list(self, data_track_list): self.data_track_list = data_track_list
    def hasContent_(self):
        if (
            self.title is not None or
            self.position is not None or
            self.format is not None or
            self.disc_list is not None or
            self.pregap is not None or
            self.track_list is not None or
            self.data_track_list is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='medium', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='medium')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='medium', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='medium'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='medium', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespace_, eol_))
        if self.position is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sposition>%s</%sposition>%s' % (namespace_, self.gds_format_integer(self.position, input_name='position'), namespace_, eol_))
        if self.format is not None:
            self.format.export(outfile, level, namespace_='mmd-2.0:', name_='format', pretty_print=pretty_print)
        if self.disc_list is not None:
            self.disc_list.export(outfile, level, namespace_='mmd-2.0:', name_='disc-list', pretty_print=pretty_print)
        if self.pregap is not None:
            self.pregap.export(outfile, level, namespace_='mmd-2.0:', name_='pregap', pretty_print=pretty_print)
        if self.track_list is not None:
            self.track_list.export(outfile, level, namespace_, name_='track-list', pretty_print=pretty_print)
        if self.data_track_list is not None:
            self.data_track_list.export(outfile, level, namespace_='mmd-2.0:', name_='data-track-list', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='medium', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.position is not None:
            position_ = self.position
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}position').text = self.gds_format_integer(position_)
        if self.format is not None:
            format_ = self.format
            format_.to_etree(element, name_='format', mapping_=mapping_)
        if self.disc_list is not None:
            disc_list_ = self.disc_list
            disc_list_.to_etree(element, name_='disc-list', mapping_=mapping_)
        if self.pregap is not None:
            pregap_ = self.pregap
            pregap_.to_etree(element, name_='pregap', mapping_=mapping_)
        if self.track_list is not None:
            track_list_ = self.track_list
            track_list_.to_etree(element, name_='track-list', mapping_=mapping_)
        if self.data_track_list is not None:
            data_track_list_ = self.data_track_list
            data_track_list_.to_etree(element, name_='data-track-list', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'position':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'position')
            self.position = ival_
        elif nodeName_ == 'format':
            obj_ = format.factory()
            obj_.build(child_)
            self.format = obj_
            obj_.original_tagname_ = 'format'
        elif nodeName_ == 'disc-list':
            obj_ = disc_list.factory()
            obj_.build(child_)
            self.disc_list = obj_
            obj_.original_tagname_ = 'disc-list'
        elif nodeName_ == 'pregap':
            obj_ = def_track_data.factory()
            obj_.build(child_)
            self.pregap = obj_
            obj_.original_tagname_ = 'pregap'
        elif nodeName_ == 'track-list':
            obj_ = track_listType17.factory()
            obj_.build(child_)
            self.track_list = obj_
            obj_.original_tagname_ = 'track-list'
        elif nodeName_ == 'data-track-list':
            obj_ = data_track_list.factory()
            obj_.build(child_)
            self.data_track_list = obj_
            obj_.original_tagname_ = 'data-track-list'
# end class medium


class format(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, format)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if format.subclass:
            return format.subclass(*args_, **kwargs_)
        else:
            return format(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='format', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='format')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='format'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='format', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='format', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.id)
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class format


class annotation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, entity=None, name=None, text=None, def_extension_element=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.entity = entity
        self.name = name
        self.text = text
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, annotation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if annotation.subclass:
            return annotation.subclass(*args_, **kwargs_)
        else:
            return annotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.entity is not None or
            self.name is not None or
            self.text is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='annotation', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='annotation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='annotation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='annotation'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='annotation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.entity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentity>%s</%sentity>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.entity), input_name='entity')), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespace_, eol_))
        if self.text is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stext>%s</%stext>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.text), input_name='text')), 'mmd-2.0:', eol_))
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='annotation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.entity is not None:
            entity_ = self.entity
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}entity').text = self.gds_format_string(entity_)
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.text is not None:
            text_ = self.text
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}text').text = self.gds_format_string(text_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entity':
            entity_ = child_.text
            entity_ = self.gds_validate_string(entity_, node, 'entity')
            self.entity = entity_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'text':
            text_ = child_.text
            text_ = self.gds_validate_string(text_, node, 'text')
            self.text = text_
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class annotation


class cdstub(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, title=None, artist=None, barcode=None, comment=None, track_list=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.title = title
        self.artist = artist
        self.barcode = barcode
        self.comment = comment
        self.track_list = track_list
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cdstub)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cdstub.subclass:
            return cdstub.subclass(*args_, **kwargs_)
        else:
            return cdstub(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_artist(self): return self.artist
    def set_artist(self, artist): self.artist = artist
    def get_barcode(self): return self.barcode
    def set_barcode(self, barcode): self.barcode = barcode
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_track_list(self): return self.track_list
    def set_track_list(self, track_list): self.track_list = track_list
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.title is not None or
            self.artist is not None or
            self.barcode is not None or
            self.comment is not None or
            self.track_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='cdstub', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cdstub')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='cdstub', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='cdstub'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='cdstub', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), 'mmd-2.0:', eol_))
        if self.artist is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartist>%s</%sartist>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.artist), input_name='artist')), namespace_, eol_))
        if self.barcode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbarcode>%s</%sbarcode>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.barcode), input_name='barcode')), namespace_, eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.comment), input_name='comment')), namespace_, eol_))
        if self.track_list is not None:
            self.track_list.export(outfile, level, namespace_, name_='track-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='cdstub', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.artist is not None:
            artist_ = self.artist
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}artist').text = self.gds_format_string(artist_)
        if self.barcode is not None:
            barcode_ = self.barcode
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}barcode').text = self.gds_format_string(barcode_)
        if self.comment is not None:
            comment_ = self.comment
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}comment').text = self.gds_format_string(comment_)
        if self.track_list is not None:
            track_list_ = self.track_list
            track_list_.to_etree(element, name_='track-list', mapping_=mapping_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'artist':
            artist_ = child_.text
            artist_ = self.gds_validate_string(artist_, node, 'artist')
            self.artist = artist_
        elif nodeName_ == 'barcode':
            barcode_ = child_.text
            barcode_ = self.gds_validate_string(barcode_, node, 'barcode')
            self.barcode = barcode_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
        elif nodeName_ == 'track-list':
            obj_ = track_listType18.factory()
            obj_.build(child_)
            self.track_list = obj_
            obj_.original_tagname_ = 'track-list'
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class cdstub


class freedb_disc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, title=None, artist=None, category=None, year=None, track_list=None, def_extension_element=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.title = title
        self.artist = artist
        self.category = category
        self.year = year
        self.validate_year(self.year)
        self.track_list = track_list
        if def_extension_element is None:
            self.def_extension_element = []
        else:
            self.def_extension_element = def_extension_element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, freedb_disc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if freedb_disc.subclass:
            return freedb_disc.subclass(*args_, **kwargs_)
        else:
            return freedb_disc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_artist(self): return self.artist
    def set_artist(self, artist): self.artist = artist
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_year(self): return self.year
    def set_year(self, year): self.year = year
    def get_track_list(self): return self.track_list
    def set_track_list(self, track_list): self.track_list = track_list
    def get_def_extension_element(self): return self.def_extension_element
    def set_def_extension_element(self, def_extension_element): self.def_extension_element = def_extension_element
    def add_def_extension_element(self, value): self.def_extension_element.append(value)
    def insert_def_extension_element_at(self, index, value): self.def_extension_element.insert(index, value)
    def replace_def_extension_element_at(self, index, value): self.def_extension_element[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_year(self, value):
        # Validate type year, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.title is not None or
            self.artist is not None or
            self.category is not None or
            self.year is not None or
            self.track_list is not None or
            self.def_extension_element
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='freedb-disc', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='freedb-disc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='freedb-disc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='freedb-disc'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='freedb-disc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), 'mmd-2.0:', eol_))
        if self.artist is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartist>%s</%sartist>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.artist), input_name='artist')), namespace_, eol_))
        if self.category is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scategory>%s</%scategory>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.category), input_name='category')), namespace_, eol_))
        if self.year is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syear>%s</%syear>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.year), input_name='year')), namespace_, eol_))
        if self.track_list is not None:
            self.track_list.export(outfile, level, namespace_, name_='track-list', pretty_print=pretty_print)
        for def_extension_element_ in self.def_extension_element:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdef_extension_element>%s</%sdef_extension_element>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(def_extension_element_), input_name='def_extension_element')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='freedb-disc', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.artist is not None:
            artist_ = self.artist
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}artist').text = self.gds_format_string(artist_)
        if self.category is not None:
            category_ = self.category
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}category').text = self.gds_format_string(category_)
        if self.year is not None:
            year_ = self.year
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}year').text = self.gds_format_string(year_)
        if self.track_list is not None:
            track_list_ = self.track_list
            track_list_.to_etree(element, name_='track-list', mapping_=mapping_)
        for def_extension_element_ in self.def_extension_element:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}def_extension_element').text = self.gds_format_string(def_extension_element_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'artist':
            artist_ = child_.text
            artist_ = self.gds_validate_string(artist_, node, 'artist')
            self.artist = artist_
        elif nodeName_ == 'category':
            category_ = child_.text
            category_ = self.gds_validate_string(category_, node, 'category')
            self.category = category_
        elif nodeName_ == 'year':
            year_ = child_.text
            year_ = self.gds_validate_string(year_, node, 'year')
            self.year = year_
            # validate type year
            self.validate_year(self.year)
        elif nodeName_ == 'track-list':
            obj_ = track_listType19.factory()
            obj_.build(child_)
            self.track_list = obj_
            obj_.original_tagname_ = 'track-list'
        elif nodeName_ == 'def_extension_element':
            def_extension_element_ = child_.text
            def_extension_element_ = self.gds_validate_string(def_extension_element_, node, 'def_extension_element')
            self.def_extension_element.append(def_extension_element_)
# end class freedb_disc


class year(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, year)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if year.subclass:
            return year.subclass(*args_, **kwargs_)
        else:
            return year(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='year', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='year')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='year', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='year'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='year', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='year', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class year


class collection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, type_id=None, entity_type=None, name=None, editor=None, area_list=None, artist_list=None, event_list=None, instrument_list=None, label_list=None, place_list=None, recording_list=None, release_list=None, release_group_list=None, series_list=None, work_list=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.entity_type = _cast(None, entity_type)
        self.name = name
        self.editor = editor
        self.area_list = area_list
        self.artist_list = artist_list
        self.event_list = event_list
        self.instrument_list = instrument_list
        self.label_list = label_list
        self.place_list = place_list
        self.recording_list = recording_list
        self.release_list = release_list
        self.release_group_list = release_group_list
        self.series_list = series_list
        self.work_list = work_list
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, collection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if collection.subclass:
            return collection.subclass(*args_, **kwargs_)
        else:
            return collection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_editor(self): return self.editor
    def set_editor(self, editor): self.editor = editor
    def get_area_list(self): return self.area_list
    def set_area_list(self, area_list): self.area_list = area_list
    def get_artist_list(self): return self.artist_list
    def set_artist_list(self, artist_list): self.artist_list = artist_list
    def get_event_list(self): return self.event_list
    def set_event_list(self, event_list): self.event_list = event_list
    def get_instrument_list(self): return self.instrument_list
    def set_instrument_list(self, instrument_list): self.instrument_list = instrument_list
    def get_label_list(self): return self.label_list
    def set_label_list(self, label_list): self.label_list = label_list
    def get_place_list(self): return self.place_list
    def set_place_list(self, place_list): self.place_list = place_list
    def get_recording_list(self): return self.recording_list
    def set_recording_list(self, recording_list): self.recording_list = recording_list
    def get_release_list(self): return self.release_list
    def set_release_list(self, release_list): self.release_list = release_list
    def get_release_group_list(self): return self.release_group_list
    def set_release_group_list(self, release_group_list): self.release_group_list = release_group_list
    def get_series_list(self): return self.series_list
    def set_series_list(self, series_list): self.series_list = series_list
    def get_work_list(self): return self.work_list
    def set_work_list(self, work_list): self.work_list = work_list
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def get_entity_type(self): return self.entity_type
    def set_entity_type(self, entity_type): self.entity_type = entity_type
    def hasContent_(self):
        if (
            self.name is not None or
            self.editor is not None or
            self.area_list is not None or
            self.artist_list is not None or
            self.event_list is not None or
            self.instrument_list is not None or
            self.label_list is not None or
            self.place_list is not None or
            self.recording_list is not None or
            self.release_list is not None or
            self.release_group_list is not None or
            self.series_list is not None or
            self.work_list is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='collection', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='collection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='collection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='collection'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
        if self.entity_type is not None and 'entity_type' not in already_processed:
            already_processed.add('entity_type')
            outfile.write(' entity-type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.entity_type), input_name='entity-type')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='collection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), 'mmd-2.0:', eol_))
        if self.editor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seditor>%s</%seditor>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.editor), input_name='editor')), namespace_, eol_))
        if self.area_list is not None:
            self.area_list.export(outfile, level, namespace_='mmd-2.0:', name_='area-list', pretty_print=pretty_print)
        if self.artist_list is not None:
            self.artist_list.export(outfile, level, namespace_='mmd-2.0:', name_='artist-list', pretty_print=pretty_print)
        if self.event_list is not None:
            self.event_list.export(outfile, level, namespace_='mmd-2.0:', name_='event-list', pretty_print=pretty_print)
        if self.instrument_list is not None:
            self.instrument_list.export(outfile, level, namespace_='mmd-2.0:', name_='instrument-list', pretty_print=pretty_print)
        if self.label_list is not None:
            self.label_list.export(outfile, level, namespace_='mmd-2.0:', name_='label-list', pretty_print=pretty_print)
        if self.place_list is not None:
            self.place_list.export(outfile, level, namespace_='mmd-2.0:', name_='place-list', pretty_print=pretty_print)
        if self.recording_list is not None:
            self.recording_list.export(outfile, level, namespace_='mmd-2.0:', name_='recording-list', pretty_print=pretty_print)
        if self.release_list is not None:
            self.release_list.export(outfile, level, namespace_='mmd-2.0:', name_='release-list', pretty_print=pretty_print)
        if self.release_group_list is not None:
            self.release_group_list.export(outfile, level, namespace_='mmd-2.0:', name_='release-group-list', pretty_print=pretty_print)
        if self.series_list is not None:
            self.series_list.export(outfile, level, namespace_='mmd-2.0:', name_='series-list', pretty_print=pretty_print)
        if self.work_list is not None:
            self.work_list.export(outfile, level, namespace_='mmd-2.0:', name_='work-list', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='collection', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.entity_type is not None:
            element.set('entity-type', self.gds_format_string(self.entity_type))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.editor is not None:
            editor_ = self.editor
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}editor').text = self.gds_format_string(editor_)
        if self.area_list is not None:
            area_list_ = self.area_list
            area_list_.to_etree(element, name_='area-list', mapping_=mapping_)
        if self.artist_list is not None:
            artist_list_ = self.artist_list
            artist_list_.to_etree(element, name_='artist-list', mapping_=mapping_)
        if self.event_list is not None:
            event_list_ = self.event_list
            event_list_.to_etree(element, name_='event-list', mapping_=mapping_)
        if self.instrument_list is not None:
            instrument_list_ = self.instrument_list
            instrument_list_.to_etree(element, name_='instrument-list', mapping_=mapping_)
        if self.label_list is not None:
            label_list_ = self.label_list
            label_list_.to_etree(element, name_='label-list', mapping_=mapping_)
        if self.place_list is not None:
            place_list_ = self.place_list
            place_list_.to_etree(element, name_='place-list', mapping_=mapping_)
        if self.recording_list is not None:
            recording_list_ = self.recording_list
            recording_list_.to_etree(element, name_='recording-list', mapping_=mapping_)
        if self.release_list is not None:
            release_list_ = self.release_list
            release_list_.to_etree(element, name_='release-list', mapping_=mapping_)
        if self.release_group_list is not None:
            release_group_list_ = self.release_group_list
            release_group_list_.to_etree(element, name_='release-group-list', mapping_=mapping_)
        if self.series_list is not None:
            series_list_ = self.series_list
            series_list_.to_etree(element, name_='series-list', mapping_=mapping_)
        if self.work_list is not None:
            work_list_ = self.work_list
            work_list_.to_etree(element, name_='work-list', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
        value = find_attr_value_('entity-type', node)
        if value is not None and 'entity-type' not in already_processed:
            already_processed.add('entity-type')
            self.entity_type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'editor':
            editor_ = child_.text
            editor_ = self.gds_validate_string(editor_, node, 'editor')
            self.editor = editor_
        elif nodeName_ == 'area-list':
            obj_ = area_list.factory()
            obj_.build(child_)
            self.area_list = obj_
            obj_.original_tagname_ = 'area-list'
        elif nodeName_ == 'artist-list':
            obj_ = artist_list.factory()
            obj_.build(child_)
            self.artist_list = obj_
            obj_.original_tagname_ = 'artist-list'
        elif nodeName_ == 'event-list':
            obj_ = event_list.factory()
            obj_.build(child_)
            self.event_list = obj_
            obj_.original_tagname_ = 'event-list'
        elif nodeName_ == 'instrument-list':
            obj_ = instrument_list.factory()
            obj_.build(child_)
            self.instrument_list = obj_
            obj_.original_tagname_ = 'instrument-list'
        elif nodeName_ == 'label-list':
            obj_ = label_list.factory()
            obj_.build(child_)
            self.label_list = obj_
            obj_.original_tagname_ = 'label-list'
        elif nodeName_ == 'place-list':
            obj_ = place_list.factory()
            obj_.build(child_)
            self.place_list = obj_
            obj_.original_tagname_ = 'place-list'
        elif nodeName_ == 'recording-list':
            obj_ = recording_list.factory()
            obj_.build(child_)
            self.recording_list = obj_
            obj_.original_tagname_ = 'recording-list'
        elif nodeName_ == 'release-list':
            obj_ = release_list.factory()
            obj_.build(child_)
            self.release_list = obj_
            obj_.original_tagname_ = 'release-list'
        elif nodeName_ == 'release-group-list':
            obj_ = release_group_list.factory()
            obj_.build(child_)
            self.release_group_list = obj_
            obj_.original_tagname_ = 'release-group-list'
        elif nodeName_ == 'series-list':
            obj_ = series_list.factory()
            obj_.build(child_)
            self.series_list = obj_
            obj_.original_tagname_ = 'series-list'
        elif nodeName_ == 'work-list':
            obj_ = work_list.factory()
            obj_.build(child_)
            self.work_list = obj_
            obj_.original_tagname_ = 'work-list'
# end class collection


class editor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, member_since=None, privs=None, gender=None, age=None, homepage=None, bio=None, area=None, language_list=None, edit_information=None):
        self.original_tagname_ = None
        self.id = _cast(int, id)
        self.name = name
        self.member_since = member_since
        self.validate_def_incomplete_date(self.member_since)
        self.privs = privs
        self.gender = gender
        self.age = age
        self.homepage = homepage
        self.bio = bio
        self.area = area
        self.language_list = language_list
        self.edit_information = edit_information
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, editor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if editor.subclass:
            return editor.subclass(*args_, **kwargs_)
        else:
            return editor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_member_since(self): return self.member_since
    def set_member_since(self, member_since): self.member_since = member_since
    def get_privs(self): return self.privs
    def set_privs(self, privs): self.privs = privs
    def get_gender(self): return self.gender
    def set_gender(self, gender): self.gender = gender
    def get_age(self): return self.age
    def set_age(self, age): self.age = age
    def get_homepage(self): return self.homepage
    def set_homepage(self, homepage): self.homepage = homepage
    def get_bio(self): return self.bio
    def set_bio(self, bio): self.bio = bio
    def get_area(self): return self.area
    def set_area(self, area): self.area = area
    def get_language_list(self): return self.language_list
    def set_language_list(self, language_list): self.language_list = language_list
    def get_edit_information(self): return self.edit_information
    def set_edit_information(self, edit_information): self.edit_information = edit_information
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_def_incomplete_date(self, value):
        # Validate type def_incomplete-date, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_incomplete_date_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_incomplete_date_patterns_, ))
    validate_def_incomplete_date_patterns_ = [['^[0-9]{4}(-[0-9]{2})?(-[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.member_since is not None or
            self.privs is not None or
            self.gender is not None or
            self.age is not None or
            self.homepage is not None or
            self.bio is not None or
            self.area is not None or
            self.language_list is not None or
            self.edit_information is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='editor', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='editor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='editor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='editor'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='editor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), 'mmd-2.0:', eol_))
        if self.member_since is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smember-since>%s</%smember-since>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.member_since), input_name='member-since')), namespace_, eol_))
        if self.privs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprivs>%s</%sprivs>%s' % (namespace_, self.gds_format_integer(self.privs, input_name='privs'), namespace_, eol_))
        if self.gender is not None:
            self.gender.export(outfile, level, namespace_='mmd-2.0:', name_='gender', pretty_print=pretty_print)
        if self.age is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sage>%s</%sage>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.age), input_name='age')), namespace_, eol_))
        if self.homepage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shomepage>%s</%shomepage>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.homepage), input_name='homepage')), namespace_, eol_))
        if self.bio is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbio>%s</%sbio>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.bio), input_name='bio')), namespace_, eol_))
        if self.area is not None:
            self.area.export(outfile, level, namespace_='mmd-2.0:', name_='area', pretty_print=pretty_print)
        if self.language_list is not None:
            self.language_list.export(outfile, level, namespace_='mmd-2.0:', name_='language-list', pretty_print=pretty_print)
        if self.edit_information is not None:
            self.edit_information.export(outfile, level, namespace_='mmd-2.0:', name_='edit-information', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='editor', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_integer(self.id))
        if self.name is not None:
            name_ = self.name
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}name').text = self.gds_format_string(name_)
        if self.member_since is not None:
            member_since_ = self.member_since
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}member-since').text = self.gds_format_string(member_since_)
        if self.privs is not None:
            privs_ = self.privs
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}privs').text = self.gds_format_integer(privs_)
        if self.gender is not None:
            gender_ = self.gender
            gender_.to_etree(element, name_='gender', mapping_=mapping_)
        if self.age is not None:
            age_ = self.age
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}age').text = self.gds_format_string(age_)
        if self.homepage is not None:
            homepage_ = self.homepage
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}homepage').text = self.gds_format_string(homepage_)
        if self.bio is not None:
            bio_ = self.bio
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}bio').text = self.gds_format_string(bio_)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_)
        if self.language_list is not None:
            language_list_ = self.language_list
            language_list_.to_etree(element, name_='language-list', mapping_=mapping_)
        if self.edit_information is not None:
            edit_information_ = self.edit_information
            edit_information_.to_etree(element, name_='edit-information', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.id < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'member-since':
            member_since_ = child_.text
            member_since_ = self.gds_validate_string(member_since_, node, 'member_since')
            self.member_since = member_since_
            # validate type def_incomplete-date
            self.validate_def_incomplete_date(self.member_since)
        elif nodeName_ == 'privs':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'privs')
            self.privs = ival_
        elif nodeName_ == 'gender':
            obj_ = gender.factory()
            obj_.build(child_)
            self.gender = obj_
            obj_.original_tagname_ = 'gender'
        elif nodeName_ == 'age':
            age_ = child_.text
            age_ = self.gds_validate_string(age_, node, 'age')
            self.age = age_
        elif nodeName_ == 'homepage':
            homepage_ = child_.text
            homepage_ = self.gds_validate_string(homepage_, node, 'homepage')
            self.homepage = homepage_
        elif nodeName_ == 'bio':
            bio_ = child_.text
            bio_ = self.gds_validate_string(bio_, node, 'bio')
            self.bio = bio_
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory()
            obj_.build(child_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'language-list':
            obj_ = language_list.factory()
            obj_.build(child_)
            self.language_list = obj_
            obj_.original_tagname_ = 'language-list'
        elif nodeName_ == 'edit-information':
            obj_ = edit_information.factory()
            obj_.build(child_)
            self.edit_information = obj_
            obj_.original_tagname_ = 'edit-information'
# end class editor


class edit_information(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, edits_accepted=None, edits_rejected=None, auto_edits_accepted=None, edits_failed=None):
        self.original_tagname_ = None
        self.edits_accepted = edits_accepted
        self.edits_rejected = edits_rejected
        self.auto_edits_accepted = auto_edits_accepted
        self.edits_failed = edits_failed
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, edit_information)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if edit_information.subclass:
            return edit_information.subclass(*args_, **kwargs_)
        else:
            return edit_information(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_edits_accepted(self): return self.edits_accepted
    def set_edits_accepted(self, edits_accepted): self.edits_accepted = edits_accepted
    def get_edits_rejected(self): return self.edits_rejected
    def set_edits_rejected(self, edits_rejected): self.edits_rejected = edits_rejected
    def get_auto_edits_accepted(self): return self.auto_edits_accepted
    def set_auto_edits_accepted(self, auto_edits_accepted): self.auto_edits_accepted = auto_edits_accepted
    def get_edits_failed(self): return self.edits_failed
    def set_edits_failed(self, edits_failed): self.edits_failed = edits_failed
    def hasContent_(self):
        if (
            self.edits_accepted is not None or
            self.edits_rejected is not None or
            self.auto_edits_accepted is not None or
            self.edits_failed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='edit-information', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='edit-information')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='edit-information', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='edit-information'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='edit-information', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.edits_accepted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sedits-accepted>%s</%sedits-accepted>%s' % (namespace_, self.gds_format_integer(self.edits_accepted, input_name='edits-accepted'), namespace_, eol_))
        if self.edits_rejected is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sedits-rejected>%s</%sedits-rejected>%s' % (namespace_, self.gds_format_integer(self.edits_rejected, input_name='edits-rejected'), namespace_, eol_))
        if self.auto_edits_accepted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sauto-edits-accepted>%s</%sauto-edits-accepted>%s' % (namespace_, self.gds_format_integer(self.auto_edits_accepted, input_name='auto-edits-accepted'), namespace_, eol_))
        if self.edits_failed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sedits-failed>%s</%sedits-failed>%s' % (namespace_, self.gds_format_integer(self.edits_failed, input_name='edits-failed'), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='edit-information', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.edits_accepted is not None:
            edits_accepted_ = self.edits_accepted
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}edits-accepted').text = self.gds_format_integer(edits_accepted_)
        if self.edits_rejected is not None:
            edits_rejected_ = self.edits_rejected
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}edits-rejected').text = self.gds_format_integer(edits_rejected_)
        if self.auto_edits_accepted is not None:
            auto_edits_accepted_ = self.auto_edits_accepted
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}auto-edits-accepted').text = self.gds_format_integer(auto_edits_accepted_)
        if self.edits_failed is not None:
            edits_failed_ = self.edits_failed
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}edits-failed').text = self.gds_format_integer(edits_failed_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'edits-accepted':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'edits_accepted')
            self.edits_accepted = ival_
        elif nodeName_ == 'edits-rejected':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'edits_rejected')
            self.edits_rejected = ival_
        elif nodeName_ == 'auto-edits-accepted':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'auto_edits_accepted')
            self.auto_edits_accepted = ival_
        elif nodeName_ == 'edits-failed':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'edits_failed')
            self.edits_failed = ival_
# end class edit_information


class language_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, language=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if language is None:
            self.language = []
        else:
            self.language = language
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, language_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if language_list.subclass:
            return language_list.subclass(*args_, **kwargs_)
        else:
            return language_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def add_language(self, value): self.language.append(value)
    def insert_language_at(self, index, value): self.language.insert(index, value)
    def replace_language_at(self, index, value): self.language[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.language
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='language-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='language-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='language-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='language-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='language-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for language_ in self.language:
            language_.export(outfile, level, namespace_, name_='language', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='language-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for language_ in self.language:
            language_.to_etree(element, name_='language', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'language':
            obj_ = languageType21.factory()
            obj_.build(child_)
            self.language.append(obj_)
            obj_.original_tagname_ = 'language'
# end class language_list


class release_event(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, date=None, area=None):
        self.original_tagname_ = None
        self.date = date
        self.validate_def_incomplete_date(self.date)
        self.area = area
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, release_event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if release_event.subclass:
            return release_event.subclass(*args_, **kwargs_)
        else:
            return release_event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_area(self): return self.area
    def set_area(self, area): self.area = area
    def validate_def_incomplete_date(self, value):
        # Validate type def_incomplete-date, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_incomplete_date_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_incomplete_date_patterns_, ))
    validate_def_incomplete_date_patterns_ = [['^[0-9]{4}(-[0-9]{2})?(-[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.date is not None or
            self.area is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='release-event', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='release-event')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='release-event', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='release-event'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='release-event', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.date), input_name='date')), namespace_, eol_))
        if self.area is not None:
            self.area.export(outfile, level, namespace_='mmd-2.0:', name_='area', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='release-event', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.date is not None:
            date_ = self.date
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}date').text = self.gds_format_string(date_)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'date':
            date_ = child_.text
            date_ = self.gds_validate_string(date_, node, 'date')
            self.date = date_
            # validate type def_incomplete-date
            self.validate_def_incomplete_date(self.date)
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory()
            obj_.build(child_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
# end class release_event


class artist_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, artist=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if artist is None:
            self.artist = []
        else:
            self.artist = artist
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, artist_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if artist_list.subclass:
            return artist_list.subclass(*args_, **kwargs_)
        else:
            return artist_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_artist(self): return self.artist
    def set_artist(self, artist): self.artist = artist
    def add_artist(self, value): self.artist.append(value)
    def insert_artist_at(self, index, value): self.artist.insert(index, value)
    def replace_artist_at(self, index, value): self.artist[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.artist
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='artist-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='artist-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='artist-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='artist-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='artist-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for artist_ in self.artist:
            artist_.export(outfile, level, namespace_='mmd-2.0:', name_='artist', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='artist-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for artist_ in self.artist:
            artist_.to_etree(element, name_='artist', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'artist':
            obj_ = artist.factory()
            obj_.build(child_)
            self.artist.append(obj_)
            obj_.original_tagname_ = 'artist'
# end class artist_list


class medium_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track_count=None, medium=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        self.track_count = track_count
        if medium is None:
            self.medium = []
        else:
            self.medium = medium
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, medium_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if medium_list.subclass:
            return medium_list.subclass(*args_, **kwargs_)
        else:
            return medium_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_track_count(self): return self.track_count
    def set_track_count(self, track_count): self.track_count = track_count
    def get_medium(self): return self.medium
    def set_medium(self, medium): self.medium = medium
    def add_medium(self, value): self.medium.append(value)
    def insert_medium_at(self, index, value): self.medium.insert(index, value)
    def replace_medium_at(self, index, value): self.medium[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.track_count is not None or
            self.medium
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='medium-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='medium-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='medium-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='medium-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='medium-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.track_count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%strack-count>%s</%strack-count>%s' % (namespace_, self.gds_format_integer(self.track_count, input_name='track-count'), namespace_, eol_))
        for medium_ in self.medium:
            medium_.export(outfile, level, namespace_='mmd-2.0:', name_='medium', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='medium-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        if self.track_count is not None:
            track_count_ = self.track_count
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}track-count').text = self.gds_format_integer(track_count_)
        for medium_ in self.medium:
            medium_.to_etree(element, name_='medium', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'track-count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'track_count')
            self.track_count = ival_
        elif nodeName_ == 'medium':
            obj_ = medium.factory()
            obj_.build(child_)
            self.medium.append(obj_)
            obj_.original_tagname_ = 'medium'
# end class medium_list


class release_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, release=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if release is None:
            self.release = []
        else:
            self.release = release
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, release_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if release_list.subclass:
            return release_list.subclass(*args_, **kwargs_)
        else:
            return release_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_release(self): return self.release
    def set_release(self, release): self.release = release
    def add_release(self, value): self.release.append(value)
    def insert_release_at(self, index, value): self.release.insert(index, value)
    def replace_release_at(self, index, value): self.release[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.release
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='release-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='release-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='release-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='release-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='release-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for release_ in self.release:
            release_.export(outfile, level, namespace_='mmd-2.0:', name_='release', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='release-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for release_ in self.release:
            release_.to_etree(element, name_='release', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'release':
            obj_ = release.factory()
            obj_.build(child_)
            self.release.append(obj_)
            obj_.original_tagname_ = 'release'
# end class release_list


class release_group_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, release_group=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if release_group is None:
            self.release_group = []
        else:
            self.release_group = release_group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, release_group_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if release_group_list.subclass:
            return release_group_list.subclass(*args_, **kwargs_)
        else:
            return release_group_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_release_group(self): return self.release_group
    def set_release_group(self, release_group): self.release_group = release_group
    def add_release_group(self, value): self.release_group.append(value)
    def insert_release_group_at(self, index, value): self.release_group.insert(index, value)
    def replace_release_group_at(self, index, value): self.release_group[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.release_group
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='release-group-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='release-group-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='release-group-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='release-group-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='release-group-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for release_group_ in self.release_group:
            release_group_.export(outfile, level, namespace_='mmd-2.0:', name_='release-group', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='release-group-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for release_group_ in self.release_group:
            release_group_.to_etree(element, name_='release-group', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'release-group':
            obj_ = release_group.factory()
            obj_.build(child_)
            self.release_group.append(obj_)
            obj_.original_tagname_ = 'release-group'
# end class release_group_list


class alias_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, alias=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if alias is None:
            self.alias = []
        else:
            self.alias = alias
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alias_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alias_list.subclass:
            return alias_list.subclass(*args_, **kwargs_)
        else:
            return alias_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_alias(self): return self.alias
    def set_alias(self, alias): self.alias = alias
    def add_alias(self, value): self.alias.append(value)
    def insert_alias_at(self, index, value): self.alias.insert(index, value)
    def replace_alias_at(self, index, value): self.alias[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.alias
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='alias-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alias-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='alias-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='alias-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='alias-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alias_ in self.alias:
            alias_.export(outfile, level, namespace_='mmd-2.0:', name_='alias', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='alias-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for alias_ in self.alias:
            alias_.to_etree(element, name_='alias', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'alias':
            obj_ = alias.factory()
            obj_.build(child_)
            self.alias.append(obj_)
            obj_.original_tagname_ = 'alias'
# end class alias_list


class recording_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, recording=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if recording is None:
            self.recording = []
        else:
            self.recording = recording
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, recording_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if recording_list.subclass:
            return recording_list.subclass(*args_, **kwargs_)
        else:
            return recording_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_recording(self): return self.recording
    def set_recording(self, recording): self.recording = recording
    def add_recording(self, value): self.recording.append(value)
    def insert_recording_at(self, index, value): self.recording.insert(index, value)
    def replace_recording_at(self, index, value): self.recording[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.recording
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='recording-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recording-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='recording-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='recording-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='recording-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for recording_ in self.recording:
            recording_.export(outfile, level, namespace_='mmd-2.0:', name_='recording', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='recording-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for recording_ in self.recording:
            recording_.to_etree(element, name_='recording', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'recording':
            obj_ = recording.factory()
            obj_.build(child_)
            self.recording.append(obj_)
            obj_.original_tagname_ = 'recording'
# end class recording_list


class data_track_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if track is None:
            self.track = []
        else:
            self.track = track
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, data_track_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if data_track_list.subclass:
            return data_track_list.subclass(*args_, **kwargs_)
        else:
            return data_track_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_track(self): return self.track
    def set_track(self, track): self.track = track
    def add_track(self, value): self.track.append(value)
    def insert_track_at(self, index, value): self.track.insert(index, value)
    def replace_track_at(self, index, value): self.track[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.track
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='data-track-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='data-track-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='data-track-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='data-track-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='data-track-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for track_ in self.track:
            track_.export(outfile, level, namespace_, name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='data-track-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for track_ in self.track:
            track_.to_etree(element, name_='track', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'track':
            obj_ = def_track_data.factory()
            obj_.build(child_)
            self.track.append(obj_)
            obj_.original_tagname_ = 'track'
# end class data_track_list


class offset_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset_attr=None, offset=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset_attr = _cast(None, offset_attr)
        if offset is None:
            self.offset = []
        else:
            self.offset = offset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, offset_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if offset_list.subclass:
            return offset_list.subclass(*args_, **kwargs_)
        else:
            return offset_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def add_offset(self, value): self.offset.append(value)
    def insert_offset_at(self, index, value): self.offset.insert(index, value)
    def replace_offset_at(self, index, value): self.offset[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset_attr(self): return self.offset_attr
    def set_offset_attr(self, offset_attr): self.offset_attr = offset_attr
    def hasContent_(self):
        if (
            self.offset
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='offset-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='offset-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='offset-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='offset-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset_attr is not None and 'offset_attr' not in already_processed:
            already_processed.add('offset_attr')
            outfile.write(' offset=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.offset_attr), input_name='offset_attr')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='offset-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for offset_ in self.offset:
            offset_.export(outfile, level, namespace_='mmd-2.0:', name_='offset', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='offset-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset_attr is not None:
            element.set('offset_attr', self.gds_format_string(self.offset_attr))
        for offset_ in self.offset:
            offset_.to_etree(element, name_='offset', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset_attr' not in already_processed:
            already_processed.add('offset_attr')
            self.offset_attr = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'offset':
            obj_ = offset.factory()
            obj_.build(child_)
            self.offset.append(obj_)
            obj_.original_tagname_ = 'offset'
# end class offset_list


class offset(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, position=None, valueOf_=None):
        self.original_tagname_ = None
        self.position = _cast(int, position)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, offset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if offset.subclass:
            return offset.subclass(*args_, **kwargs_)
        else:
            return offset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='offset', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='offset')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='offset', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='offset'):
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position="%s"' % self.gds_format_integer(self.position, input_name='position'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='offset', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='offset', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.position is not None:
            element.set('position', self.gds_format_integer(self.position))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            try:
                self.position = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.position < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class offset


class label_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, label=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if label is None:
            self.label = []
        else:
            self.label = label
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, label_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if label_list.subclass:
            return label_list.subclass(*args_, **kwargs_)
        else:
            return label_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def add_label(self, value): self.label.append(value)
    def insert_label_at(self, index, value): self.label.insert(index, value)
    def replace_label_at(self, index, value): self.label[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.label
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='label-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='label-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='label-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='label-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='label-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for label_ in self.label:
            label_.export(outfile, level, namespace_='mmd-2.0:', name_='label', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='label-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for label_ in self.label:
            label_.to_etree(element, name_='label', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'label':
            obj_ = label.factory()
            obj_.build(child_)
            self.label.append(obj_)
            obj_.original_tagname_ = 'label'
# end class label_list


class label_info_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, label_info=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if label_info is None:
            self.label_info = []
        else:
            self.label_info = label_info
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, label_info_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if label_info_list.subclass:
            return label_info_list.subclass(*args_, **kwargs_)
        else:
            return label_info_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label_info(self): return self.label_info
    def set_label_info(self, label_info): self.label_info = label_info
    def add_label_info(self, value): self.label_info.append(value)
    def insert_label_info_at(self, index, value): self.label_info.insert(index, value)
    def replace_label_info_at(self, index, value): self.label_info[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.label_info
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='label-info-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='label-info-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='label-info-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='label-info-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='label-info-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for label_info_ in self.label_info:
            label_info_.export(outfile, level, namespace_='mmd-2.0:', name_='label-info', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='label-info-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for label_info_ in self.label_info:
            label_info_.to_etree(element, name_='label-info', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'label-info':
            obj_ = label_info.factory()
            obj_.build(child_)
            self.label_info.append(obj_)
            obj_.original_tagname_ = 'label-info'
# end class label_info_list


class work_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, work=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if work is None:
            self.work = []
        else:
            self.work = work
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, work_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if work_list.subclass:
            return work_list.subclass(*args_, **kwargs_)
        else:
            return work_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_work(self): return self.work
    def set_work(self, work): self.work = work
    def add_work(self, value): self.work.append(value)
    def insert_work_at(self, index, value): self.work.insert(index, value)
    def replace_work_at(self, index, value): self.work[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.work
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='work-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='work-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='work-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='work-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='work-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for work_ in self.work:
            work_.export(outfile, level, namespace_='mmd-2.0:', name_='work', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='work-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for work_ in self.work:
            work_.to_etree(element, name_='work', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'work':
            obj_ = work.factory()
            obj_.build(child_)
            self.work.append(obj_)
            obj_.original_tagname_ = 'work'
# end class work_list


class area_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, area=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if area is None:
            self.area = []
        else:
            self.area = area
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, area_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if area_list.subclass:
            return area_list.subclass(*args_, **kwargs_)
        else:
            return area_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_area(self): return self.area
    def set_area(self, area): self.area = area
    def add_area(self, value): self.area.append(value)
    def insert_area_at(self, index, value): self.area.insert(index, value)
    def replace_area_at(self, index, value): self.area[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.area
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='area-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='area-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='area-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='area-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='area-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for area_ in self.area:
            area_.export(outfile, level, namespace_='mmd-2.0:', name_='area', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='area-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for area_ in self.area:
            area_.to_etree(element, name_='area', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'area':
            obj_ = def_area_element_inner.factory()
            obj_.build(child_)
            self.area.append(obj_)
            obj_.original_tagname_ = 'area'
# end class area_list


class place_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, place=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if place is None:
            self.place = []
        else:
            self.place = place
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, place_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if place_list.subclass:
            return place_list.subclass(*args_, **kwargs_)
        else:
            return place_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_place(self): return self.place
    def set_place(self, place): self.place = place
    def add_place(self, value): self.place.append(value)
    def insert_place_at(self, index, value): self.place.insert(index, value)
    def replace_place_at(self, index, value): self.place[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.place
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='place-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='place-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='place-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='place-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='place-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for place_ in self.place:
            place_.export(outfile, level, namespace_='mmd-2.0:', name_='place', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='place-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for place_ in self.place:
            place_.to_etree(element, name_='place', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'place':
            obj_ = place.factory()
            obj_.build(child_)
            self.place.append(obj_)
            obj_.original_tagname_ = 'place'
# end class place_list


class instrument_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, instrument=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if instrument is None:
            self.instrument = []
        else:
            self.instrument = instrument
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instrument_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instrument_list.subclass:
            return instrument_list.subclass(*args_, **kwargs_)
        else:
            return instrument_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instrument(self): return self.instrument
    def set_instrument(self, instrument): self.instrument = instrument
    def add_instrument(self, value): self.instrument.append(value)
    def insert_instrument_at(self, index, value): self.instrument.insert(index, value)
    def replace_instrument_at(self, index, value): self.instrument[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.instrument
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='instrument-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='instrument-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='instrument-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='instrument-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='instrument-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for instrument_ in self.instrument:
            instrument_.export(outfile, level, namespace_='mmd-2.0:', name_='instrument', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='instrument-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for instrument_ in self.instrument:
            instrument_.to_etree(element, name_='instrument', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instrument':
            obj_ = instrument.factory()
            obj_.build(child_)
            self.instrument.append(obj_)
            obj_.original_tagname_ = 'instrument'
# end class instrument_list


class series_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, series=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if series is None:
            self.series = []
        else:
            self.series = series
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, series_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if series_list.subclass:
            return series_list.subclass(*args_, **kwargs_)
        else:
            return series_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_series(self): return self.series
    def set_series(self, series): self.series = series
    def add_series(self, value): self.series.append(value)
    def insert_series_at(self, index, value): self.series.insert(index, value)
    def replace_series_at(self, index, value): self.series[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.series
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='series-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='series-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='series-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='series-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='series-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for series_ in self.series:
            series_.export(outfile, level, namespace_='mmd-2.0:', name_='series', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='series-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for series_ in self.series:
            series_.to_etree(element, name_='series', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'series':
            obj_ = series.factory()
            obj_.build(child_)
            self.series.append(obj_)
            obj_.original_tagname_ = 'series'
# end class series_list


class event_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, event=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if event is None:
            self.event = []
        else:
            self.event = event
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, event_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if event_list.subclass:
            return event_list.subclass(*args_, **kwargs_)
        else:
            return event_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_event(self): return self.event
    def set_event(self, event): self.event = event
    def add_event(self, value): self.event.append(value)
    def insert_event_at(self, index, value): self.event.insert(index, value)
    def replace_event_at(self, index, value): self.event[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.event
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='event-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='event-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='event-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='event-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='event-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for event_ in self.event:
            event_.export(outfile, level, namespace_='mmd-2.0:', name_='event', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='event-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for event_ in self.event:
            event_.to_etree(element, name_='event', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'event':
            obj_ = event.factory()
            obj_.build(child_)
            self.event.append(obj_)
            obj_.original_tagname_ = 'event'
# end class event_list


class url_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, url=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if url is None:
            self.url = []
        else:
            self.url = url
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, url_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if url_list.subclass:
            return url_list.subclass(*args_, **kwargs_)
        else:
            return url_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def add_url(self, value): self.url.append(value)
    def insert_url_at(self, index, value): self.url.insert(index, value)
    def replace_url_at(self, index, value): self.url[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.url
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='url-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='url-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='url-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='url-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='url-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for url_ in self.url:
            url_.export(outfile, level, namespace_='mmd-2.0:', name_='url', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='url-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for url_ in self.url:
            url_.to_etree(element, name_='url', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'url':
            obj_ = url.factory()
            obj_.build(child_)
            self.url.append(obj_)
            obj_.original_tagname_ = 'url'
# end class url_list


class release_event_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, release_event=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if release_event is None:
            self.release_event = []
        else:
            self.release_event = release_event
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, release_event_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if release_event_list.subclass:
            return release_event_list.subclass(*args_, **kwargs_)
        else:
            return release_event_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_release_event(self): return self.release_event
    def set_release_event(self, release_event): self.release_event = release_event
    def add_release_event(self, value): self.release_event.append(value)
    def insert_release_event_at(self, index, value): self.release_event.insert(index, value)
    def replace_release_event_at(self, index, value): self.release_event[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.release_event
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='release-event-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='release-event-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='release-event-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='release-event-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='release-event-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for release_event_ in self.release_event:
            release_event_.export(outfile, level, namespace_='mmd-2.0:', name_='release-event', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='release-event-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for release_event_ in self.release_event:
            release_event_.to_etree(element, name_='release-event', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'release-event':
            obj_ = release_event.factory()
            obj_.build(child_)
            self.release_event.append(obj_)
            obj_.original_tagname_ = 'release-event'
# end class release_event_list


class annotation_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, annotation=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, annotation_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if annotation_list.subclass:
            return annotation_list.subclass(*args_, **kwargs_)
        else:
            return annotation_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def add_annotation(self, value): self.annotation.append(value)
    def insert_annotation_at(self, index, value): self.annotation.insert(index, value)
    def replace_annotation_at(self, index, value): self.annotation[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.annotation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='annotation-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='annotation-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='annotation-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='annotation-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='annotation-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for annotation_ in self.annotation:
            annotation_.export(outfile, level, namespace_='mmd-2.0:', name_='annotation', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='annotation-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for annotation_ in self.annotation:
            annotation_.to_etree(element, name_='annotation', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotation':
            obj_ = annotation.factory()
            obj_.build(child_)
            self.annotation.append(obj_)
            obj_.original_tagname_ = 'annotation'
# end class annotation_list


class cdstub_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, cdstub=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if cdstub is None:
            self.cdstub = []
        else:
            self.cdstub = cdstub
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cdstub_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cdstub_list.subclass:
            return cdstub_list.subclass(*args_, **kwargs_)
        else:
            return cdstub_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cdstub(self): return self.cdstub
    def set_cdstub(self, cdstub): self.cdstub = cdstub
    def add_cdstub(self, value): self.cdstub.append(value)
    def insert_cdstub_at(self, index, value): self.cdstub.insert(index, value)
    def replace_cdstub_at(self, index, value): self.cdstub[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.cdstub
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='cdstub-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cdstub-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='cdstub-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='cdstub-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='cdstub-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cdstub_ in self.cdstub:
            cdstub_.export(outfile, level, namespace_='mmd-2.0:', name_='cdstub', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='cdstub-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for cdstub_ in self.cdstub:
            cdstub_.to_etree(element, name_='cdstub', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cdstub':
            obj_ = cdstub.factory()
            obj_.build(child_)
            self.cdstub.append(obj_)
            obj_.original_tagname_ = 'cdstub'
# end class cdstub_list


class freedb_disc_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, freedb_disc=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if freedb_disc is None:
            self.freedb_disc = []
        else:
            self.freedb_disc = freedb_disc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, freedb_disc_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if freedb_disc_list.subclass:
            return freedb_disc_list.subclass(*args_, **kwargs_)
        else:
            return freedb_disc_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_freedb_disc(self): return self.freedb_disc
    def set_freedb_disc(self, freedb_disc): self.freedb_disc = freedb_disc
    def add_freedb_disc(self, value): self.freedb_disc.append(value)
    def insert_freedb_disc_at(self, index, value): self.freedb_disc.insert(index, value)
    def replace_freedb_disc_at(self, index, value): self.freedb_disc[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.freedb_disc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='freedb-disc-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='freedb-disc-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='freedb-disc-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='freedb-disc-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='freedb-disc-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for freedb_disc_ in self.freedb_disc:
            freedb_disc_.export(outfile, level, namespace_='mmd-2.0:', name_='freedb-disc', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='freedb-disc-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for freedb_disc_ in self.freedb_disc:
            freedb_disc_.to_etree(element, name_='freedb-disc', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'freedb-disc':
            obj_ = freedb_disc.factory()
            obj_.build(child_)
            self.freedb_disc.append(obj_)
            obj_.original_tagname_ = 'freedb-disc'
# end class freedb_disc_list


class disc_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, disc=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if disc is None:
            self.disc = []
        else:
            self.disc = disc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, disc_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if disc_list.subclass:
            return disc_list.subclass(*args_, **kwargs_)
        else:
            return disc_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_disc(self): return self.disc
    def set_disc(self, disc): self.disc = disc
    def add_disc(self, value): self.disc.append(value)
    def insert_disc_at(self, index, value): self.disc.insert(index, value)
    def replace_disc_at(self, index, value): self.disc[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.disc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='disc-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='disc-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='disc-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='disc-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='disc-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for disc_ in self.disc:
            disc_.export(outfile, level, namespace_='mmd-2.0:', name_='disc', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='disc-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for disc_ in self.disc:
            disc_.to_etree(element, name_='disc', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'disc':
            obj_ = disc.factory()
            obj_.build(child_)
            self.disc.append(obj_)
            obj_.original_tagname_ = 'disc'
# end class disc_list


class puid_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, puid=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if puid is None:
            self.puid = []
        else:
            self.puid = puid
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, puid_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if puid_list.subclass:
            return puid_list.subclass(*args_, **kwargs_)
        else:
            return puid_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_puid(self): return self.puid
    def set_puid(self, puid): self.puid = puid
    def add_puid(self, value): self.puid.append(value)
    def insert_puid_at(self, index, value): self.puid.insert(index, value)
    def replace_puid_at(self, index, value): self.puid[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.puid
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='puid-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='puid-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='puid-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='puid-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='puid-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for puid_ in self.puid:
            puid_.export(outfile, level, namespace_='mmd-2.0:', name_='puid', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='puid-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for puid_ in self.puid:
            puid_.to_etree(element, name_='puid', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'puid':
            obj_ = puid.factory()
            obj_.build(child_)
            self.puid.append(obj_)
            obj_.original_tagname_ = 'puid'
# end class puid_list


class isrc_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, isrc=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if isrc is None:
            self.isrc = []
        else:
            self.isrc = isrc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, isrc_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if isrc_list.subclass:
            return isrc_list.subclass(*args_, **kwargs_)
        else:
            return isrc_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isrc(self): return self.isrc
    def set_isrc(self, isrc): self.isrc = isrc
    def add_isrc(self, value): self.isrc.append(value)
    def insert_isrc_at(self, index, value): self.isrc.insert(index, value)
    def replace_isrc_at(self, index, value): self.isrc[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.isrc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='isrc-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isrc-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='isrc-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='isrc-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='isrc-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for isrc_ in self.isrc:
            isrc_.export(outfile, level, namespace_='mmd-2.0:', name_='isrc', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='isrc-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for isrc_ in self.isrc:
            isrc_.to_etree(element, name_='isrc', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isrc':
            obj_ = isrc.factory()
            obj_.build(child_)
            self.isrc.append(obj_)
            obj_.original_tagname_ = 'isrc'
# end class isrc_list


class relation_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, target_type=None, count=None, offset=None, relation=None):
        self.original_tagname_ = None
        self.target_type = _cast(None, target_type)
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if relation is None:
            self.relation = []
        else:
            self.relation = relation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, relation_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if relation_list.subclass:
            return relation_list.subclass(*args_, **kwargs_)
        else:
            return relation_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relation(self): return self.relation
    def set_relation(self, relation): self.relation = relation
    def add_relation(self, value): self.relation.append(value)
    def insert_relation_at(self, index, value): self.relation.insert(index, value)
    def replace_relation_at(self, index, value): self.relation[index] = value
    def get_target_type(self): return self.target_type
    def set_target_type(self, target_type): self.target_type = target_type
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.relation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='relation-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='relation-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='relation-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='relation-list'):
        if self.target_type is not None and 'target_type' not in already_processed:
            already_processed.add('target_type')
            outfile.write(' target-type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.target_type), input_name='target-type')), ))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='relation-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for relation_ in self.relation:
            relation_.export(outfile, level, namespace_='mmd-2.0:', name_='relation', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='relation-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.target_type is not None:
            element.set('target-type', self.gds_format_string(self.target_type))
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for relation_ in self.relation:
            relation_.to_etree(element, name_='relation', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target-type', node)
        if value is not None and 'target-type' not in already_processed:
            already_processed.add('target-type')
            self.target_type = value
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'relation':
            obj_ = relation.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'relation'
# end class relation_list


class tag_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, tag=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if tag is None:
            self.tag = []
        else:
            self.tag = tag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tag_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tag_list.subclass:
            return tag_list.subclass(*args_, **kwargs_)
        else:
            return tag_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tag(self): return self.tag
    def set_tag(self, tag): self.tag = tag
    def add_tag(self, value): self.tag.append(value)
    def insert_tag_at(self, index, value): self.tag.insert(index, value)
    def replace_tag_at(self, index, value): self.tag[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='tag-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tag-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='tag-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='tag-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='tag-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tag_ in self.tag:
            tag_.export(outfile, level, namespace_='mmd-2.0:', name_='tag', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='tag-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for tag_ in self.tag:
            tag_.to_etree(element, name_='tag', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tag':
            obj_ = tag.factory()
            obj_.build(child_)
            self.tag.append(obj_)
            obj_.original_tagname_ = 'tag'
# end class tag_list


class iswc_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, iswc=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if iswc is None:
            self.iswc = []
        else:
            self.iswc = iswc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, iswc_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if iswc_list.subclass:
            return iswc_list.subclass(*args_, **kwargs_)
        else:
            return iswc_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_iswc(self): return self.iswc
    def set_iswc(self, iswc): self.iswc = iswc
    def add_iswc(self, value): self.iswc.append(value)
    def insert_iswc_at(self, index, value): self.iswc.insert(index, value)
    def replace_iswc_at(self, index, value): self.iswc[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def validate_iswc(self, value):
        # Validate type iswc, a restriction on xs:token.
        pass
    def hasContent_(self):
        if (
            self.iswc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='iswc-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='iswc-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='iswc-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='iswc-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='iswc-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for iswc_ in self.iswc:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%siswc>%s</%siswc>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(iswc_), input_name='iswc')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='iswc-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for iswc_ in self.iswc:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}iswc').text = self.gds_format_string(iswc_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'iswc':
            iswc_ = child_.text
            if iswc_:
                iswc_ = re_.sub(String_cleanup_pat_, " ", iswc_).strip()
            else:
                iswc_ = ""
            iswc_ = self.gds_validate_string(iswc_, node, 'iswc')
            self.iswc.append(iswc_)
            # validate type iswc
            self.validate_iswc(self.iswc[-1])
# end class iswc_list


class user_tag_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, user_tag=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if user_tag is None:
            self.user_tag = []
        else:
            self.user_tag = user_tag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, user_tag_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if user_tag_list.subclass:
            return user_tag_list.subclass(*args_, **kwargs_)
        else:
            return user_tag_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_user_tag(self): return self.user_tag
    def set_user_tag(self, user_tag): self.user_tag = user_tag
    def add_user_tag(self, value): self.user_tag.append(value)
    def insert_user_tag_at(self, index, value): self.user_tag.insert(index, value)
    def replace_user_tag_at(self, index, value): self.user_tag[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.user_tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='user-tag-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='user-tag-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='user-tag-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='user-tag-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='user-tag-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for user_tag_ in self.user_tag:
            user_tag_.export(outfile, level, namespace_='mmd-2.0:', name_='user-tag', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='user-tag-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for user_tag_ in self.user_tag:
            user_tag_.to_etree(element, name_='user-tag', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'user-tag':
            obj_ = user_tag.factory()
            obj_.build(child_)
            self.user_tag.append(obj_)
            obj_.original_tagname_ = 'user-tag'
# end class user_tag_list


class collection_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, collection=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if collection is None:
            self.collection = []
        else:
            self.collection = collection
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, collection_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if collection_list.subclass:
            return collection_list.subclass(*args_, **kwargs_)
        else:
            return collection_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_collection(self): return self.collection
    def set_collection(self, collection): self.collection = collection
    def add_collection(self, value): self.collection.append(value)
    def insert_collection_at(self, index, value): self.collection.insert(index, value)
    def replace_collection_at(self, index, value): self.collection[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.collection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='collection-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='collection-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='collection-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='collection-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='collection-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for collection_ in self.collection:
            collection_.export(outfile, level, namespace_='mmd-2.0:', name_='collection', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='collection-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for collection_ in self.collection:
            collection_.to_etree(element, name_='collection', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'collection':
            obj_ = collection.factory()
            obj_.build(child_)
            self.collection.append(obj_)
            obj_.original_tagname_ = 'collection'
# end class collection_list


class editor_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, editor=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if editor is None:
            self.editor = []
        else:
            self.editor = editor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, editor_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if editor_list.subclass:
            return editor_list.subclass(*args_, **kwargs_)
        else:
            return editor_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_editor(self): return self.editor
    def set_editor(self, editor): self.editor = editor
    def add_editor(self, value): self.editor.append(value)
    def insert_editor_at(self, index, value): self.editor.insert(index, value)
    def replace_editor_at(self, index, value): self.editor[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.editor
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='editor-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='editor-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='editor-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='editor-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='editor-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for editor_ in self.editor:
            editor_.export(outfile, level, namespace_='mmd-2.0:', name_='editor', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='editor-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for editor_ in self.editor:
            editor_.to_etree(element, name_='editor', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'editor':
            obj_ = editor.factory()
            obj_.build(child_)
            self.editor.append(obj_)
            obj_.original_tagname_ = 'editor'
# end class editor_list


class entity_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, artist=None, release=None, release_group=None, recording=None, label=None, work=None, area=None, place=None, instrument=None, series=None, event=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if artist is None:
            self.artist = []
        else:
            self.artist = artist
        if release is None:
            self.release = []
        else:
            self.release = release
        if release_group is None:
            self.release_group = []
        else:
            self.release_group = release_group
        if recording is None:
            self.recording = []
        else:
            self.recording = recording
        if label is None:
            self.label = []
        else:
            self.label = label
        if work is None:
            self.work = []
        else:
            self.work = work
        if area is None:
            self.area = []
        else:
            self.area = area
        if place is None:
            self.place = []
        else:
            self.place = place
        if instrument is None:
            self.instrument = []
        else:
            self.instrument = instrument
        if series is None:
            self.series = []
        else:
            self.series = series
        if event is None:
            self.event = []
        else:
            self.event = event
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, entity_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if entity_list.subclass:
            return entity_list.subclass(*args_, **kwargs_)
        else:
            return entity_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_artist(self): return self.artist
    def set_artist(self, artist): self.artist = artist
    def add_artist(self, value): self.artist.append(value)
    def insert_artist_at(self, index, value): self.artist.insert(index, value)
    def replace_artist_at(self, index, value): self.artist[index] = value
    def get_release(self): return self.release
    def set_release(self, release): self.release = release
    def add_release(self, value): self.release.append(value)
    def insert_release_at(self, index, value): self.release.insert(index, value)
    def replace_release_at(self, index, value): self.release[index] = value
    def get_release_group(self): return self.release_group
    def set_release_group(self, release_group): self.release_group = release_group
    def add_release_group(self, value): self.release_group.append(value)
    def insert_release_group_at(self, index, value): self.release_group.insert(index, value)
    def replace_release_group_at(self, index, value): self.release_group[index] = value
    def get_recording(self): return self.recording
    def set_recording(self, recording): self.recording = recording
    def add_recording(self, value): self.recording.append(value)
    def insert_recording_at(self, index, value): self.recording.insert(index, value)
    def replace_recording_at(self, index, value): self.recording[index] = value
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def add_label(self, value): self.label.append(value)
    def insert_label_at(self, index, value): self.label.insert(index, value)
    def replace_label_at(self, index, value): self.label[index] = value
    def get_work(self): return self.work
    def set_work(self, work): self.work = work
    def add_work(self, value): self.work.append(value)
    def insert_work_at(self, index, value): self.work.insert(index, value)
    def replace_work_at(self, index, value): self.work[index] = value
    def get_area(self): return self.area
    def set_area(self, area): self.area = area
    def add_area(self, value): self.area.append(value)
    def insert_area_at(self, index, value): self.area.insert(index, value)
    def replace_area_at(self, index, value): self.area[index] = value
    def get_place(self): return self.place
    def set_place(self, place): self.place = place
    def add_place(self, value): self.place.append(value)
    def insert_place_at(self, index, value): self.place.insert(index, value)
    def replace_place_at(self, index, value): self.place[index] = value
    def get_instrument(self): return self.instrument
    def set_instrument(self, instrument): self.instrument = instrument
    def add_instrument(self, value): self.instrument.append(value)
    def insert_instrument_at(self, index, value): self.instrument.insert(index, value)
    def replace_instrument_at(self, index, value): self.instrument[index] = value
    def get_series(self): return self.series
    def set_series(self, series): self.series = series
    def add_series(self, value): self.series.append(value)
    def insert_series_at(self, index, value): self.series.insert(index, value)
    def replace_series_at(self, index, value): self.series[index] = value
    def get_event(self): return self.event
    def set_event(self, event): self.event = event
    def add_event(self, value): self.event.append(value)
    def insert_event_at(self, index, value): self.event.insert(index, value)
    def replace_event_at(self, index, value): self.event[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.artist or
            self.release or
            self.release_group or
            self.recording or
            self.label or
            self.work or
            self.area or
            self.place or
            self.instrument or
            self.series or
            self.event
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='entity-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entity-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='entity-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='entity-list'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='entity-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for artist_ in self.artist:
            artist_.export(outfile, level, namespace_='mmd-2.0:', name_='artist', pretty_print=pretty_print)
        for release_ in self.release:
            release_.export(outfile, level, namespace_='mmd-2.0:', name_='release', pretty_print=pretty_print)
        for release_group_ in self.release_group:
            release_group_.export(outfile, level, namespace_='mmd-2.0:', name_='release-group', pretty_print=pretty_print)
        for recording_ in self.recording:
            recording_.export(outfile, level, namespace_='mmd-2.0:', name_='recording', pretty_print=pretty_print)
        for label_ in self.label:
            label_.export(outfile, level, namespace_='mmd-2.0:', name_='label', pretty_print=pretty_print)
        for work_ in self.work:
            work_.export(outfile, level, namespace_='mmd-2.0:', name_='work', pretty_print=pretty_print)
        for area_ in self.area:
            area_.export(outfile, level, namespace_='mmd-2.0:', name_='area', pretty_print=pretty_print)
        for place_ in self.place:
            place_.export(outfile, level, namespace_='mmd-2.0:', name_='place', pretty_print=pretty_print)
        for instrument_ in self.instrument:
            instrument_.export(outfile, level, namespace_='mmd-2.0:', name_='instrument', pretty_print=pretty_print)
        for series_ in self.series:
            series_.export(outfile, level, namespace_='mmd-2.0:', name_='series', pretty_print=pretty_print)
        for event_ in self.event:
            event_.export(outfile, level, namespace_='mmd-2.0:', name_='event', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='entity-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for artist_ in self.artist:
            artist_.to_etree(element, name_='artist', mapping_=mapping_)
        for release_ in self.release:
            release_.to_etree(element, name_='release', mapping_=mapping_)
        for release_group_ in self.release_group:
            release_group_.to_etree(element, name_='release-group', mapping_=mapping_)
        for recording_ in self.recording:
            recording_.to_etree(element, name_='recording', mapping_=mapping_)
        for label_ in self.label:
            label_.to_etree(element, name_='label', mapping_=mapping_)
        for work_ in self.work:
            work_.to_etree(element, name_='work', mapping_=mapping_)
        for area_ in self.area:
            area_.to_etree(element, name_='area', mapping_=mapping_)
        for place_ in self.place:
            place_.to_etree(element, name_='place', mapping_=mapping_)
        for instrument_ in self.instrument:
            instrument_.to_etree(element, name_='instrument', mapping_=mapping_)
        for series_ in self.series:
            series_.to_etree(element, name_='series', mapping_=mapping_)
        for event_ in self.event:
            event_.to_etree(element, name_='event', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'artist':
            obj_ = artist.factory()
            obj_.build(child_)
            self.artist.append(obj_)
            obj_.original_tagname_ = 'artist'
        elif nodeName_ == 'release':
            obj_ = release.factory()
            obj_.build(child_)
            self.release.append(obj_)
            obj_.original_tagname_ = 'release'
        elif nodeName_ == 'release-group':
            obj_ = release_group.factory()
            obj_.build(child_)
            self.release_group.append(obj_)
            obj_.original_tagname_ = 'release-group'
        elif nodeName_ == 'recording':
            obj_ = recording.factory()
            obj_.build(child_)
            self.recording.append(obj_)
            obj_.original_tagname_ = 'recording'
        elif nodeName_ == 'label':
            obj_ = label.factory()
            obj_.build(child_)
            self.label.append(obj_)
            obj_.original_tagname_ = 'label'
        elif nodeName_ == 'work':
            obj_ = work.factory()
            obj_.build(child_)
            self.work.append(obj_)
            obj_.original_tagname_ = 'work'
        elif nodeName_ == 'area':
            obj_ = def_area_element_inner.factory()
            obj_.build(child_)
            self.area.append(obj_)
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'place':
            obj_ = place.factory()
            obj_.build(child_)
            self.place.append(obj_)
            obj_.original_tagname_ = 'place'
        elif nodeName_ == 'instrument':
            obj_ = instrument.factory()
            obj_.build(child_)
            self.instrument.append(obj_)
            obj_.original_tagname_ = 'instrument'
        elif nodeName_ == 'series':
            obj_ = series.factory()
            obj_.build(child_)
            self.series.append(obj_)
            obj_.original_tagname_ = 'series'
        elif nodeName_ == 'event':
            obj_ = event.factory()
            obj_.build(child_)
            self.event.append(obj_)
            obj_.original_tagname_ = 'event'
# end class entity_list


class cover_art_archive(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, artwork=None, count=None, front=None, back=None, darkened=None):
        self.original_tagname_ = None
        self.artwork = artwork
        self.validate_artwork(self.artwork)
        self.count = count
        self.front = front
        self.validate_front(self.front)
        self.back = back
        self.validate_back(self.back)
        self.darkened = darkened
        self.validate_darkened(self.darkened)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cover_art_archive)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cover_art_archive.subclass:
            return cover_art_archive.subclass(*args_, **kwargs_)
        else:
            return cover_art_archive(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_artwork(self): return self.artwork
    def set_artwork(self, artwork): self.artwork = artwork
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_front(self): return self.front
    def set_front(self, front): self.front = front
    def get_back(self): return self.back
    def set_back(self, back): self.back = back
    def get_darkened(self): return self.darkened
    def set_darkened(self, darkened): self.darkened = darkened
    def validate_artwork(self, value):
        # Validate type artwork, a restriction on xs:token.
        pass
    def validate_front(self, value):
        # Validate type front, a restriction on xs:token.
        pass
    def validate_back(self, value):
        # Validate type back, a restriction on xs:token.
        pass
    def validate_darkened(self, value):
        # Validate type darkened, a restriction on xs:token.
        pass
    def hasContent_(self):
        if (
            self.artwork is not None or
            self.count is not None or
            self.front is not None or
            self.back is not None or
            self.darkened is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='cover-art-archive', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cover-art-archive')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='cover-art-archive', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='cover-art-archive'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='cover-art-archive', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.artwork is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartwork>%s</%sartwork>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.artwork), input_name='artwork')), 'mmd-2.0:', eol_))
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespace_, self.gds_format_integer(self.count, input_name='count'), namespace_, eol_))
        if self.front is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfront>%s</%sfront>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.front), input_name='front')), 'mmd-2.0:', eol_))
        if self.back is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sback>%s</%sback>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.back), input_name='back')), 'mmd-2.0:', eol_))
        if self.darkened is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdarkened>%s</%sdarkened>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.darkened), input_name='darkened')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='cover-art-archive', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.artwork is not None:
            artwork_ = self.artwork
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}artwork').text = self.gds_format_string(artwork_)
        if self.count is not None:
            count_ = self.count
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}count').text = self.gds_format_integer(count_)
        if self.front is not None:
            front_ = self.front
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}front').text = self.gds_format_string(front_)
        if self.back is not None:
            back_ = self.back
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}back').text = self.gds_format_string(back_)
        if self.darkened is not None:
            darkened_ = self.darkened
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}darkened').text = self.gds_format_string(darkened_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'artwork':
            artwork_ = child_.text
            if artwork_:
                artwork_ = re_.sub(String_cleanup_pat_, " ", artwork_).strip()
            else:
                artwork_ = ""
            artwork_ = self.gds_validate_string(artwork_, node, 'artwork')
            self.artwork = artwork_
            # validate type artwork
            self.validate_artwork(self.artwork)
        elif nodeName_ == 'count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'front':
            front_ = child_.text
            if front_:
                front_ = re_.sub(String_cleanup_pat_, " ", front_).strip()
            else:
                front_ = ""
            front_ = self.gds_validate_string(front_, node, 'front')
            self.front = front_
            # validate type front
            self.validate_front(self.front)
        elif nodeName_ == 'back':
            back_ = child_.text
            if back_:
                back_ = re_.sub(String_cleanup_pat_, " ", back_).strip()
            else:
                back_ = ""
            back_ = self.gds_validate_string(back_, node, 'back')
            self.back = back_
            # validate type back
            self.validate_back(self.back)
        elif nodeName_ == 'darkened':
            darkened_ = child_.text
            if darkened_:
                darkened_ = re_.sub(String_cleanup_pat_, " ", darkened_).strip()
            else:
                darkened_ = ""
            darkened_ = self.gds_validate_string(darkened_, node, 'darkened')
            self.darkened = darkened_
            # validate type darkened
            self.validate_darkened(self.darkened)
# end class cover_art_archive


class artwork(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, artwork)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if artwork.subclass:
            return artwork.subclass(*args_, **kwargs_)
        else:
            return artwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='artwork', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='artwork')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='artwork', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='artwork'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='artwork', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='artwork', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class artwork


class front(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, front)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if front.subclass:
            return front.subclass(*args_, **kwargs_)
        else:
            return front(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='front', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='front')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='front', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='front'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='front', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='front', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class front


class back(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, back)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if back.subclass:
            return back.subclass(*args_, **kwargs_)
        else:
            return back(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='back', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='back')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='back', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='back'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='back', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='back', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class back


class darkened(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, darkened)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if darkened.subclass:
            return darkened.subclass(*args_, **kwargs_)
        else:
            return darkened(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='darkened', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='darkened')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='darkened', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='darkened'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='darkened', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='darkened', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class darkened


class ipi_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ipi=None):
        self.original_tagname_ = None
        if ipi is None:
            self.ipi = []
        else:
            self.ipi = ipi
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ipi_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ipi_list.subclass:
            return ipi_list.subclass(*args_, **kwargs_)
        else:
            return ipi_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ipi(self): return self.ipi
    def set_ipi(self, ipi): self.ipi = ipi
    def add_ipi(self, value): self.ipi.append(value)
    def insert_ipi_at(self, index, value): self.ipi.insert(index, value)
    def replace_ipi_at(self, index, value): self.ipi[index] = value
    def validate_def_ipi(self, value):
        # Validate type def_ipi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_ipi_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_ipi_patterns_, ))
    validate_def_ipi_patterns_ = [['^[0-9]{11}$']]
    def hasContent_(self):
        if (
            self.ipi
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='ipi-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ipi-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='ipi-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='ipi-list'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='ipi-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ipi_ in self.ipi:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sipi>%s</%sipi>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(ipi_), input_name='ipi')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='ipi-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        for ipi_ in self.ipi:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}ipi').text = self.gds_format_string(ipi_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ipi':
            ipi_ = child_.text
            ipi_ = self.gds_validate_string(ipi_, node, 'ipi')
            self.ipi.append(ipi_)
            # validate type def_ipi
            self.validate_def_ipi(self.ipi[-1])
# end class ipi_list


class ended(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ended)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ended.subclass:
            return ended.subclass(*args_, **kwargs_)
        else:
            return ended(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='ended', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ended')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='ended', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='ended'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='ended', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ended', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ended


class cancelled(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cancelled)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cancelled.subclass:
            return cancelled.subclass(*args_, **kwargs_)
        else:
            return cancelled(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='cancelled', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cancelled')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='cancelled', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='cancelled'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='cancelled', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='cancelled', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cancelled


class video(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, video)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if video.subclass:
            return video.subclass(*args_, **kwargs_)
        else:
            return video(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='video', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='video')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='video', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='video'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='video', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='video', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class video


class iso_3166_1_code_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iso_3166_1_code=None):
        self.original_tagname_ = None
        if iso_3166_1_code is None:
            self.iso_3166_1_code = []
        else:
            self.iso_3166_1_code = iso_3166_1_code
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, iso_3166_1_code_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if iso_3166_1_code_list.subclass:
            return iso_3166_1_code_list.subclass(*args_, **kwargs_)
        else:
            return iso_3166_1_code_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_iso_3166_1_code(self): return self.iso_3166_1_code
    def set_iso_3166_1_code(self, iso_3166_1_code): self.iso_3166_1_code = iso_3166_1_code
    def add_iso_3166_1_code(self, value): self.iso_3166_1_code.append(value)
    def insert_iso_3166_1_code_at(self, index, value): self.iso_3166_1_code.insert(index, value)
    def replace_iso_3166_1_code_at(self, index, value): self.iso_3166_1_code[index] = value
    def validate_def_iso_3166_1_code(self, value):
        # Validate type def_iso-3166-1-code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_3166_1_code_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_iso_3166_1_code_patterns_, ))
    validate_def_iso_3166_1_code_patterns_ = [['^[A-Z]{2}$']]
    def hasContent_(self):
        if (
            self.iso_3166_1_code
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='iso-3166-1-code-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='iso-3166-1-code-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='iso-3166-1-code-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='iso-3166-1-code-list'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='iso-3166-1-code-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for iso_3166_1_code_ in self.iso_3166_1_code:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%siso-3166-1-code>%s</%siso-3166-1-code>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(iso_3166_1_code_), input_name='iso-3166-1-code')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='iso-3166-1-code-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        for iso_3166_1_code_ in self.iso_3166_1_code:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}iso-3166-1-code').text = self.gds_format_string(iso_3166_1_code_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'iso-3166-1-code':
            iso_3166_1_code_ = child_.text
            iso_3166_1_code_ = self.gds_validate_string(iso_3166_1_code_, node, 'iso_3166_1_code')
            self.iso_3166_1_code.append(iso_3166_1_code_)
            # validate type def_iso-3166-1-code
            self.validate_def_iso_3166_1_code(self.iso_3166_1_code[-1])
# end class iso_3166_1_code_list


class iso_3166_2_code_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iso_3166_2_code=None):
        self.original_tagname_ = None
        if iso_3166_2_code is None:
            self.iso_3166_2_code = []
        else:
            self.iso_3166_2_code = iso_3166_2_code
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, iso_3166_2_code_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if iso_3166_2_code_list.subclass:
            return iso_3166_2_code_list.subclass(*args_, **kwargs_)
        else:
            return iso_3166_2_code_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_iso_3166_2_code(self): return self.iso_3166_2_code
    def set_iso_3166_2_code(self, iso_3166_2_code): self.iso_3166_2_code = iso_3166_2_code
    def add_iso_3166_2_code(self, value): self.iso_3166_2_code.append(value)
    def insert_iso_3166_2_code_at(self, index, value): self.iso_3166_2_code.insert(index, value)
    def replace_iso_3166_2_code_at(self, index, value): self.iso_3166_2_code[index] = value
    def validate_def_iso_3166_2_code(self, value):
        # Validate type def_iso-3166-2-code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_3166_2_code_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_iso_3166_2_code_patterns_, ))
    validate_def_iso_3166_2_code_patterns_ = [['^[A-Z]{2}\\-[A-Z0-9]+$']]
    def hasContent_(self):
        if (
            self.iso_3166_2_code
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='iso-3166-2-code-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='iso-3166-2-code-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='iso-3166-2-code-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='iso-3166-2-code-list'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='iso-3166-2-code-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for iso_3166_2_code_ in self.iso_3166_2_code:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%siso-3166-2-code>%s</%siso-3166-2-code>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(iso_3166_2_code_), input_name='iso-3166-2-code')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='iso-3166-2-code-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        for iso_3166_2_code_ in self.iso_3166_2_code:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}iso-3166-2-code').text = self.gds_format_string(iso_3166_2_code_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'iso-3166-2-code':
            iso_3166_2_code_ = child_.text
            iso_3166_2_code_ = self.gds_validate_string(iso_3166_2_code_, node, 'iso_3166_2_code')
            self.iso_3166_2_code.append(iso_3166_2_code_)
            # validate type def_iso-3166-2-code
            self.validate_def_iso_3166_2_code(self.iso_3166_2_code[-1])
# end class iso_3166_2_code_list


class iso_3166_3_code_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iso_3166_3_code=None):
        self.original_tagname_ = None
        if iso_3166_3_code is None:
            self.iso_3166_3_code = []
        else:
            self.iso_3166_3_code = iso_3166_3_code
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, iso_3166_3_code_list)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if iso_3166_3_code_list.subclass:
            return iso_3166_3_code_list.subclass(*args_, **kwargs_)
        else:
            return iso_3166_3_code_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_iso_3166_3_code(self): return self.iso_3166_3_code
    def set_iso_3166_3_code(self, iso_3166_3_code): self.iso_3166_3_code = iso_3166_3_code
    def add_iso_3166_3_code(self, value): self.iso_3166_3_code.append(value)
    def insert_iso_3166_3_code_at(self, index, value): self.iso_3166_3_code.insert(index, value)
    def replace_iso_3166_3_code_at(self, index, value): self.iso_3166_3_code[index] = value
    def validate_def_iso_3166_3_code(self, value):
        # Validate type def_iso-3166-3-code, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_iso_3166_3_code_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_iso_3166_3_code_patterns_, ))
    validate_def_iso_3166_3_code_patterns_ = [['^[A-Z]{4}$']]
    def hasContent_(self):
        if (
            self.iso_3166_3_code
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='iso-3166-3-code-list', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='iso-3166-3-code-list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='iso-3166-3-code-list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='iso-3166-3-code-list'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='iso-3166-3-code-list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for iso_3166_3_code_ in self.iso_3166_3_code:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%siso-3166-3-code>%s</%siso-3166-3-code>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(iso_3166_3_code_), input_name='iso-3166-3-code')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='iso-3166-3-code-list', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        for iso_3166_3_code_ in self.iso_3166_3_code:
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}iso-3166-3-code').text = self.gds_format_string(iso_3166_3_code_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'iso-3166-3-code':
            iso_3166_3_code_ = child_.text
            iso_3166_3_code_ = self.gds_validate_string(iso_3166_3_code_, node, 'iso_3166_3_code')
            self.iso_3166_3_code.append(iso_3166_3_code_)
            # validate type def_iso-3166-3-code
            self.validate_def_iso_3166_3_code(self.iso_3166_3_code[-1])
# end class iso_3166_3_code_list


class attribute_listType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attribute=None):
        self.original_tagname_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType.subclass:
            return attribute_listType.subclass(*args_, **kwargs_)
        else:
            return attribute_listType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute_at(self, index, value): self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value): self.attribute[index] = value
    def hasContent_(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute-listType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='attribute-listType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attribute-listType'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attributeType.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType


class attributeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, type_id=None, value_id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.value_id = _cast(None, value_id)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType.subclass:
            return attributeType.subclass(*args_, **kwargs_)
        else:
            return attributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def get_value_id(self): return self.value_id
    def set_value_id(self, value_id): self.value_id = value_id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attributeType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attributeType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
        if self.value_id is not None and 'value_id' not in already_processed:
            already_processed.add('value_id')
            outfile.write(' value-id=%s' % (quote_attrib(self.value_id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.value_id is not None:
            element.set('value-id', self.value_id)
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
        value = find_attr_value_('value-id', node)
        if value is not None and 'value-id' not in already_processed:
            already_processed.add('value-id')
            self.value_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType


class life_spanType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, begin=None, end=None):
        self.original_tagname_ = None
        self.begin = begin
        self.validate_def_incomplete_date(self.begin)
        self.end = end
        self.validate_def_incomplete_date(self.end)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, life_spanType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if life_spanType.subclass:
            return life_spanType.subclass(*args_, **kwargs_)
        else:
            return life_spanType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def validate_def_incomplete_date(self, value):
        # Validate type def_incomplete-date, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_incomplete_date_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_incomplete_date_patterns_, ))
    validate_def_incomplete_date_patterns_ = [['^[0-9]{4}(-[0-9]{2})?(-[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.begin is not None or
            self.end is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='life-spanType', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='life-spanType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='life-spanType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='life-spanType'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='life-spanType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.begin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbegin>%s</%sbegin>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.begin), input_name='begin')), namespace_, eol_))
        if self.end is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%send>%s</%send>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.end), input_name='end')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='life-spanType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.begin is not None:
            begin_ = self.begin
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}begin').text = self.gds_format_string(begin_)
        if self.end is not None:
            end_ = self.end
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}end').text = self.gds_format_string(end_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'begin':
            begin_ = child_.text
            begin_ = self.gds_validate_string(begin_, node, 'begin')
            self.begin = begin_
            # validate type def_incomplete-date
            self.validate_def_incomplete_date(self.begin)
        elif nodeName_ == 'end':
            end_ = child_.text
            end_ = self.gds_validate_string(end_, node, 'end')
            self.end = end_
            # validate type def_incomplete-date
            self.validate_def_incomplete_date(self.end)
# end class life_spanType


class attribute_listType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attribute=None):
        self.original_tagname_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType1.subclass:
            return attribute_listType1.subclass(*args_, **kwargs_)
        else:
            return attribute_listType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute_at(self, index, value): self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value): self.attribute[index] = value
    def hasContent_(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType1', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute-listType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='attribute-listType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attribute-listType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType1', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attributeType2.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType1


class attributeType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, credited_as=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.credited_as = _cast(None, credited_as)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType2.subclass:
            return attributeType2.subclass(*args_, **kwargs_)
        else:
            return attributeType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_credited_as(self): return self.credited_as
    def set_credited_as(self, credited_as): self.credited_as = credited_as
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType2', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attributeType2')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attributeType2'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.credited_as is not None and 'credited_as' not in already_processed:
            already_processed.add('credited_as')
            outfile.write(' credited-as=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.credited_as), input_name='credited-as')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType2', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType2', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.credited_as is not None:
            element.set('credited-as', self.gds_format_string(self.credited_as))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('credited-as', node)
        if value is not None and 'credited-as' not in already_processed:
            already_processed.add('credited-as')
            self.credited_as = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType2


class track_listType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        self.track = track
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType.subclass:
            return track_listType.subclass(*args_, **kwargs_)
        else:
            return track_listType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_track(self): return self.track
    def set_track(self, track): self.track = track
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.track is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='track-listType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='track-listType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='track-listType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.track is not None:
            self.track.export(outfile, level, namespace_, name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        if self.track is not None:
            track_ = self.track
            track_.to_etree(element, name_='track', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'track':
            obj_ = def_track_data.factory()
            obj_.build(child_)
            self.track = obj_
            obj_.original_tagname_ = 'track'
# end class track_listType


class track_listType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        self.track = track
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType3.subclass:
            return track_listType3.subclass(*args_, **kwargs_)
        else:
            return track_listType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_track(self): return self.track
    def set_track(self, track): self.track = track
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.track is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType3', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='track-listType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='track-listType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='track-listType3'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.track is not None:
            self.track.export(outfile, level, namespace_, name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType3', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        if self.track is not None:
            track_ = self.track
            track_.to_etree(element, name_='track', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'track':
            obj_ = trackType20.factory()
            obj_.build(child_)
            self.track = obj_
            obj_.original_tagname_ = 'track'
# end class track_listType3


class track_listType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        self.track = track
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType4.subclass:
            return track_listType4.subclass(*args_, **kwargs_)
        else:
            return track_listType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_track(self): return self.track
    def set_track(self, track): self.track = track
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.track is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType4', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='track-listType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='track-listType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='track-listType4'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.track is not None:
            self.track.export(outfile, level, namespace_, name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType4', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        if self.track is not None:
            track_ = self.track
            track_.to_etree(element, name_='track', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'track':
            obj_ = trackType20.factory()
            obj_.build(child_)
            self.track = obj_
            obj_.original_tagname_ = 'track'
# end class track_listType4


class trackType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, title=None, artist=None, length=None):
        self.original_tagname_ = None
        self.title = title
        self.artist = artist
        self.length = length
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackType.subclass:
            return trackType.subclass(*args_, **kwargs_)
        else:
            return trackType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_artist(self): return self.artist
    def set_artist(self, artist): self.artist = artist
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def hasContent_(self):
        if (
            self.title is not None or
            self.artist is not None or
            self.length is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='trackType', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='trackType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='trackType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='trackType'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='trackType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), 'mmd-2.0:', eol_))
        if self.artist is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartist>%s</%sartist>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.artist), input_name='artist')), namespace_, eol_))
        if self.length is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespace_, self.gds_format_integer(self.length, input_name='length'), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='trackType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.artist is not None:
            artist_ = self.artist
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}artist').text = self.gds_format_string(artist_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}length').text = self.gds_format_integer(length_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'artist':
            artist_ = child_.text
            artist_ = self.gds_validate_string(artist_, node, 'artist')
            self.artist = artist_
        elif nodeName_ == 'length':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
# end class trackType


class languageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fluency=None, valueOf_=None):
        self.original_tagname_ = None
        self.fluency = _cast(None, fluency)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, languageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if languageType.subclass:
            return languageType.subclass(*args_, **kwargs_)
        else:
            return languageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fluency(self): return self.fluency
    def set_fluency(self, fluency): self.fluency = fluency
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='languageType', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='languageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='languageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='languageType'):
        if self.fluency is not None and 'fluency' not in already_processed:
            already_processed.add('fluency')
            outfile.write(' fluency=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fluency), input_name='fluency')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='languageType', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='languageType', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.fluency is not None:
            element.set('fluency', self.gds_format_string(self.fluency))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fluency', node)
        if value is not None and 'fluency' not in already_processed:
            already_processed.add('fluency')
            self.fluency = value
            self.fluency = ' '.join(self.fluency.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class languageType


class track_listType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if track is None:
            self.track = []
        else:
            self.track = track
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType5.subclass:
            return track_listType5.subclass(*args_, **kwargs_)
        else:
            return track_listType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_track(self): return self.track
    def set_track(self, track): self.track = track
    def add_track(self, value): self.track.append(value)
    def insert_track_at(self, index, value): self.track.insert(index, value)
    def replace_track_at(self, index, value): self.track[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.track
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType5', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='track-listType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='track-listType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='track-listType5'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for track_ in self.track:
            track_.export(outfile, level, namespace_, name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType5', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for track_ in self.track:
            track_.to_etree(element, name_='track', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'track':
            obj_ = def_track_data.factory()
            obj_.build(child_)
            self.track.append(obj_)
            obj_.original_tagname_ = 'track'
# end class track_listType5


class track_listType6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if track is None:
            self.track = []
        else:
            self.track = track
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType6.subclass:
            return track_listType6.subclass(*args_, **kwargs_)
        else:
            return track_listType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_track(self): return self.track
    def set_track(self, track): self.track = track
    def add_track(self, value): self.track.append(value)
    def insert_track_at(self, index, value): self.track.insert(index, value)
    def replace_track_at(self, index, value): self.track[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.track
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType6', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='track-listType6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='track-listType6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='track-listType6'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for track_ in self.track:
            track_.export(outfile, level, namespace_, name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType6', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for track_ in self.track:
            track_.to_etree(element, name_='track', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'track':
            obj_ = trackType7.factory()
            obj_.build(child_)
            self.track.append(obj_)
            obj_.original_tagname_ = 'track'
# end class track_listType6


class trackType7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, title=None, artist=None, length=None):
        self.original_tagname_ = None
        self.title = title
        self.artist = artist
        self.length = length
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackType7.subclass:
            return trackType7.subclass(*args_, **kwargs_)
        else:
            return trackType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_artist(self): return self.artist
    def set_artist(self, artist): self.artist = artist
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def hasContent_(self):
        if (
            self.title is not None or
            self.artist is not None or
            self.length is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='trackType7', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='trackType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='trackType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='trackType7'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='trackType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), 'mmd-2.0:', eol_))
        if self.artist is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartist>%s</%sartist>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.artist), input_name='artist')), namespace_, eol_))
        if self.length is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespace_, self.gds_format_integer(self.length, input_name='length'), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='trackType7', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.artist is not None:
            artist_ = self.artist
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}artist').text = self.gds_format_string(artist_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}length').text = self.gds_format_integer(length_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'artist':
            artist_ = child_.text
            artist_ = self.gds_validate_string(artist_, node, 'artist')
            self.artist = artist_
        elif nodeName_ == 'length':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
# end class trackType7


class attribute_listType8(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attribute=None):
        self.original_tagname_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType8.subclass:
            return attribute_listType8.subclass(*args_, **kwargs_)
        else:
            return attribute_listType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute_at(self, index, value): self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value): self.attribute[index] = value
    def hasContent_(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType8', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute-listType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='attribute-listType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attribute-listType8'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType8', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attributeType9.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType8


class attributeType9(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, credited_as=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.credited_as = _cast(None, credited_as)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType9.subclass:
            return attributeType9.subclass(*args_, **kwargs_)
        else:
            return attributeType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_credited_as(self): return self.credited_as
    def set_credited_as(self, credited_as): self.credited_as = credited_as
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType9', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attributeType9')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attributeType9'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.credited_as is not None and 'credited_as' not in already_processed:
            already_processed.add('credited_as')
            outfile.write(' credited-as=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.credited_as), input_name='credited-as')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType9', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType9', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.credited_as is not None:
            element.set('credited-as', self.gds_format_string(self.credited_as))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('credited-as', node)
        if value is not None and 'credited-as' not in already_processed:
            already_processed.add('credited-as')
            self.credited_as = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType9


class attribute_listType10(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attribute=None):
        self.original_tagname_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType10.subclass:
            return attribute_listType10.subclass(*args_, **kwargs_)
        else:
            return attribute_listType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute_at(self, index, value): self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value): self.attribute[index] = value
    def hasContent_(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType10', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute-listType10')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='attribute-listType10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attribute-listType10'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType10', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType10', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attributeType11.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType10


class attributeType11(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, type_id=None, value_id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.value_id = _cast(None, value_id)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType11.subclass:
            return attributeType11.subclass(*args_, **kwargs_)
        else:
            return attributeType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def get_value_id(self): return self.value_id
    def set_value_id(self, value_id): self.value_id = value_id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType11', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attributeType11')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attributeType11'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
        if self.value_id is not None and 'value_id' not in already_processed:
            already_processed.add('value_id')
            outfile.write(' value-id=%s' % (quote_attrib(self.value_id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType11', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType11', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.value_id is not None:
            element.set('value-id', self.value_id)
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
        value = find_attr_value_('value-id', node)
        if value is not None and 'value-id' not in already_processed:
            already_processed.add('value-id')
            self.value_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType11


class attribute_listType12(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attribute=None):
        self.original_tagname_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType12.subclass:
            return attribute_listType12.subclass(*args_, **kwargs_)
        else:
            return attribute_listType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute_at(self, index, value): self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value): self.attribute[index] = value
    def hasContent_(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType12', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute-listType12')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='attribute-listType12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attribute-listType12'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType12', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attributeType13.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType12


class attributeType13(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, type_id=None, value_id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.value_id = _cast(None, value_id)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType13.subclass:
            return attributeType13.subclass(*args_, **kwargs_)
        else:
            return attributeType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def get_value_id(self): return self.value_id
    def set_value_id(self, value_id): self.value_id = value_id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType13', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attributeType13')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attributeType13'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
        if self.value_id is not None and 'value_id' not in already_processed:
            already_processed.add('value_id')
            outfile.write(' value-id=%s' % (quote_attrib(self.value_id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType13', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType13', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.value_id is not None:
            element.set('value-id', self.value_id)
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
        value = find_attr_value_('value-id', node)
        if value is not None and 'value-id' not in already_processed:
            already_processed.add('value-id')
            self.value_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType13


class life_spanType14(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, begin=None, end=None):
        self.original_tagname_ = None
        self.begin = begin
        self.validate_def_incomplete_date(self.begin)
        self.end = end
        self.validate_def_incomplete_date(self.end)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, life_spanType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if life_spanType14.subclass:
            return life_spanType14.subclass(*args_, **kwargs_)
        else:
            return life_spanType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def validate_def_incomplete_date(self, value):
        # Validate type def_incomplete-date, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_def_incomplete_date_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_def_incomplete_date_patterns_, ))
    validate_def_incomplete_date_patterns_ = [['^[0-9]{4}(-[0-9]{2})?(-[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.begin is not None or
            self.end is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='life-spanType14', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='life-spanType14')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='life-spanType14', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='life-spanType14'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='life-spanType14', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.begin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbegin>%s</%sbegin>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.begin), input_name='begin')), namespace_, eol_))
        if self.end is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%send>%s</%send>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.end), input_name='end')), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='life-spanType14', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.begin is not None:
            begin_ = self.begin
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}begin').text = self.gds_format_string(begin_)
        if self.end is not None:
            end_ = self.end
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}end').text = self.gds_format_string(end_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'begin':
            begin_ = child_.text
            begin_ = self.gds_validate_string(begin_, node, 'begin')
            self.begin = begin_
            # validate type def_incomplete-date
            self.validate_def_incomplete_date(self.begin)
        elif nodeName_ == 'end':
            end_ = child_.text
            end_ = self.gds_validate_string(end_, node, 'end')
            self.end = end_
            # validate type def_incomplete-date
            self.validate_def_incomplete_date(self.end)
# end class life_spanType14


class attribute_listType15(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attribute=None):
        self.original_tagname_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType15.subclass:
            return attribute_listType15.subclass(*args_, **kwargs_)
        else:
            return attribute_listType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute_at(self, index, value): self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value): self.attribute[index] = value
    def hasContent_(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType15', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute-listType15')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='attribute-listType15', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attribute-listType15'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType15', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType15', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attributeType16.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType15


class attributeType16(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, credited_as=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.credited_as = _cast(None, credited_as)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType16.subclass:
            return attributeType16.subclass(*args_, **kwargs_)
        else:
            return attributeType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_credited_as(self): return self.credited_as
    def set_credited_as(self, credited_as): self.credited_as = credited_as
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType16', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attributeType16')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attributeType16'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.credited_as is not None and 'credited_as' not in already_processed:
            already_processed.add('credited_as')
            outfile.write(' credited-as=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.credited_as), input_name='credited-as')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType16', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType16', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.credited_as is not None:
            element.set('credited-as', self.gds_format_string(self.credited_as))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('credited-as', node)
        if value is not None and 'credited-as' not in already_processed:
            already_processed.add('credited-as')
            self.credited_as = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType16


class track_listType17(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        self.track = track
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType17.subclass:
            return track_listType17.subclass(*args_, **kwargs_)
        else:
            return track_listType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_track(self): return self.track
    def set_track(self, track): self.track = track
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.track is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType17', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='track-listType17')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='track-listType17', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='track-listType17'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType17', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.track is not None:
            self.track.export(outfile, level, namespace_, name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType17', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        if self.track is not None:
            track_ = self.track
            track_.to_etree(element, name_='track', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'track':
            obj_ = def_track_data.factory()
            obj_.build(child_)
            self.track = obj_
            obj_.original_tagname_ = 'track'
# end class track_listType17


class track_listType18(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        self.track = track
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType18.subclass:
            return track_listType18.subclass(*args_, **kwargs_)
        else:
            return track_listType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_track(self): return self.track
    def set_track(self, track): self.track = track
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.track is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType18', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='track-listType18')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='track-listType18', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='track-listType18'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType18', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.track is not None:
            self.track.export(outfile, level, namespace_, name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType18', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        if self.track is not None:
            track_ = self.track
            track_.to_etree(element, name_='track', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'track':
            obj_ = trackType20.factory()
            obj_.build(child_)
            self.track = obj_
            obj_.original_tagname_ = 'track'
# end class track_listType18


class track_listType19(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        self.track = track
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType19.subclass:
            return track_listType19.subclass(*args_, **kwargs_)
        else:
            return track_listType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_track(self): return self.track
    def set_track(self, track): self.track = track
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.track is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType19', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='track-listType19')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='track-listType19', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='track-listType19'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType19', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.track is not None:
            self.track.export(outfile, level, namespace_, name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType19', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        if self.track is not None:
            track_ = self.track
            track_.to_etree(element, name_='track', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'track':
            obj_ = trackType20.factory()
            obj_.build(child_)
            self.track = obj_
            obj_.original_tagname_ = 'track'
# end class track_listType19


class trackType20(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, title=None, artist=None, length=None):
        self.original_tagname_ = None
        self.title = title
        self.artist = artist
        self.length = length
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackType20.subclass:
            return trackType20.subclass(*args_, **kwargs_)
        else:
            return trackType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_artist(self): return self.artist
    def set_artist(self, artist): self.artist = artist
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def hasContent_(self):
        if (
            self.title is not None or
            self.artist is not None or
            self.length is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='trackType20', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='trackType20')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='trackType20', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='trackType20'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='trackType20', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), 'mmd-2.0:', eol_))
        if self.artist is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartist>%s</%sartist>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.artist), input_name='artist')), namespace_, eol_))
        if self.length is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespace_, self.gds_format_integer(self.length, input_name='length'), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='trackType20', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.artist is not None:
            artist_ = self.artist
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}artist').text = self.gds_format_string(artist_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}length').text = self.gds_format_integer(length_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'artist':
            artist_ = child_.text
            artist_ = self.gds_validate_string(artist_, node, 'artist')
            self.artist = artist_
        elif nodeName_ == 'length':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
# end class trackType20


class languageType21(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fluency=None, valueOf_=None):
        self.original_tagname_ = None
        self.fluency = _cast(None, fluency)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, languageType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if languageType21.subclass:
            return languageType21.subclass(*args_, **kwargs_)
        else:
            return languageType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fluency(self): return self.fluency
    def set_fluency(self, fluency): self.fluency = fluency
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='languageType21', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='languageType21')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='languageType21', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='languageType21'):
        if self.fluency is not None and 'fluency' not in already_processed:
            already_processed.add('fluency')
            outfile.write(' fluency=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fluency), input_name='fluency')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='languageType21', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='languageType21', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.fluency is not None:
            element.set('fluency', self.gds_format_string(self.fluency))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fluency', node)
        if value is not None and 'fluency' not in already_processed:
            already_processed.add('fluency')
            self.fluency = value
            self.fluency = ' '.join(self.fluency.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class languageType21


class track_listType22(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if track is None:
            self.track = []
        else:
            self.track = track
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType22.subclass:
            return track_listType22.subclass(*args_, **kwargs_)
        else:
            return track_listType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_track(self): return self.track
    def set_track(self, track): self.track = track
    def add_track(self, value): self.track.append(value)
    def insert_track_at(self, index, value): self.track.insert(index, value)
    def replace_track_at(self, index, value): self.track[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.track
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType22', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='track-listType22')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='track-listType22', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='track-listType22'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType22', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for track_ in self.track:
            track_.export(outfile, level, namespace_, name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType22', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for track_ in self.track:
            track_.to_etree(element, name_='track', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'track':
            obj_ = def_track_data.factory()
            obj_.build(child_)
            self.track.append(obj_)
            obj_.original_tagname_ = 'track'
# end class track_listType22


class track_listType23(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, offset=None, track=None):
        self.original_tagname_ = None
        self.count = _cast(int, count)
        self.offset = _cast(int, offset)
        if track is None:
            self.track = []
        else:
            self.track = track
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, track_listType23)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if track_listType23.subclass:
            return track_listType23.subclass(*args_, **kwargs_)
        else:
            return track_listType23(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_track(self): return self.track
    def set_track(self, track): self.track = track
    def add_track(self, value): self.track.append(value)
    def insert_track_at(self, index, value): self.track.insert(index, value)
    def replace_track_at(self, index, value): self.track[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def hasContent_(self):
        if (
            self.track
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType23', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='track-listType23')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='track-listType23', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='track-listType23'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='track-listType23', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for track_ in self.track:
            track_.export(outfile, level, namespace_, name_='track', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='track-listType23', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if self.offset is not None:
            element.set('offset', self.gds_format_integer(self.offset))
        for track_ in self.track:
            track_.to_etree(element, name_='track', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            try:
                self.offset = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.offset < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'track':
            obj_ = trackType24.factory()
            obj_.build(child_)
            self.track.append(obj_)
            obj_.original_tagname_ = 'track'
# end class track_listType23


class trackType24(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, title=None, artist=None, length=None):
        self.original_tagname_ = None
        self.title = title
        self.artist = artist
        self.length = length
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, trackType24)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if trackType24.subclass:
            return trackType24.subclass(*args_, **kwargs_)
        else:
            return trackType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_artist(self): return self.artist
    def set_artist(self, artist): self.artist = artist
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def hasContent_(self):
        if (
            self.title is not None or
            self.artist is not None or
            self.length is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='trackType24', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='trackType24')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='trackType24', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='trackType24'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='trackType24', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % ('mmd-2.0:', self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), 'mmd-2.0:', eol_))
        if self.artist is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sartist>%s</%sartist>%s' % (namespace_, self.gds_encode(self.gds_format_string(quote_xml(self.artist), input_name='artist')), namespace_, eol_))
        if self.length is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slength>%s</%slength>%s' % (namespace_, self.gds_format_integer(self.length, input_name='length'), namespace_, eol_))
    def to_etree(self, parent_element=None, name_='trackType24', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.title is not None:
            title_ = self.title
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}title').text = self.gds_format_string(title_)
        if self.artist is not None:
            artist_ = self.artist
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}artist').text = self.gds_format_string(artist_)
        if self.length is not None:
            length_ = self.length
            etree_.SubElement(element, '{http://musicbrainz.org/ns/mmd-2.0#}length').text = self.gds_format_integer(length_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'artist':
            artist_ = child_.text
            artist_ = self.gds_validate_string(artist_, node, 'artist')
            self.artist = artist_
        elif nodeName_ == 'length':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'length')
            self.length = ival_
# end class trackType24


class attribute_listType25(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attribute=None):
        self.original_tagname_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType25.subclass:
            return attribute_listType25.subclass(*args_, **kwargs_)
        else:
            return attribute_listType25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute_at(self, index, value): self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value): self.attribute[index] = value
    def hasContent_(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType25', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute-listType25')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='attribute-listType25', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attribute-listType25'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType25', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType25', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attributeType26.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType25


class attributeType26(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, credited_as=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.credited_as = _cast(None, credited_as)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType26)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType26.subclass:
            return attributeType26.subclass(*args_, **kwargs_)
        else:
            return attributeType26(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_credited_as(self): return self.credited_as
    def set_credited_as(self, credited_as): self.credited_as = credited_as
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType26', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attributeType26')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attributeType26'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.credited_as is not None and 'credited_as' not in already_processed:
            already_processed.add('credited_as')
            outfile.write(' credited-as=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.credited_as), input_name='credited-as')), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType26', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType26', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if self.credited_as is not None:
            element.set('credited-as', self.gds_format_string(self.credited_as))
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('credited-as', node)
        if value is not None and 'credited-as' not in already_processed:
            already_processed.add('credited-as')
            self.credited_as = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType26


class attribute_listType27(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attribute=None):
        self.original_tagname_ = None
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attribute_listType27)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attribute_listType27.subclass:
            return attribute_listType27.subclass(*args_, **kwargs_)
        else:
            return attribute_listType27(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute_at(self, index, value): self.attribute.insert(index, value)
    def replace_attribute_at(self, index, value): self.attribute[index] = value
    def hasContent_(self):
        if (
            self.attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType27', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute-listType27')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='mmd-2.0:', name_='attribute-listType27', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attribute-listType27'):
        pass
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attribute-listType27', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='attribute-listType27', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        for attribute_ in self.attribute:
            attribute_.to_etree(element, name_='attribute', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attribute':
            obj_ = attributeType28.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
# end class attribute_listType27


class attributeType28(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, type_id=None, value_id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.type_id = _cast(None, type_id)
        self.value_id = _cast(None, value_id)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributeType28)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributeType28.subclass:
            return attributeType28.subclass(*args_, **kwargs_)
        else:
            return attributeType28(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_type_id(self): return self.type_id
    def set_type_id(self, type_id): self.type_id = type_id
    def get_value_id(self): return self.value_id
    def set_value_id(self, value_id): self.value_id = value_id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType28', namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attributeType28')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='mmd-2.0:', name_='attributeType28'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.type_id is not None and 'type_id' not in already_processed:
            already_processed.add('type_id')
            outfile.write(' type-id=%s' % (quote_attrib(self.type_id), ))
        if self.value_id is not None and 'value_id' not in already_processed:
            already_processed.add('value_id')
            outfile.write(' value-id=%s' % (quote_attrib(self.value_id), ))
    def exportChildren(self, outfile, level, namespace_='mmd-2.0:', name_='attributeType28', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='attributeType28', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://musicbrainz.org/ns/mmd-2.0#}' + name_)
        if self.type_ is not None:
            element.set('type', self.gds_format_string(self.type_))
        if self.type_id is not None:
            element.set('type-id', self.type_id)
        if self.value_id is not None:
            element.set('value-id', self.value_id)
        if self.hasContent_():
            element.text = self.gds_format_string(self.get_valueOf_())
        if mapping_ is not None:
            mapping_[self] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('type-id', node)
        if value is not None and 'type-id' not in already_processed:
            already_processed.add('type-id')
            self.type_id = value
        value = find_attr_value_('value-id', node)
        if value is not None and 'value-id' not in already_processed:
            already_processed.add('value-id')
            self.value_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class attributeType28


GDSClassesMapping = {
    'area': def_area_element_inner,
    'attribute': attributeType28,
    'attribute-list': attribute_listType15,
    'begin-area': def_area_element_inner,
    'end-area': def_area_element_inner,
    'language': languageType21,
    'life-span': life_spanType14,
    'pregap': def_track_data,
    'track': trackType24,
    'track-list': track_listType19,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'def_area_element_inner'
        rootClass = def_area_element_inner
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'def_area_element_inner'
        rootClass = def_area_element_inner
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'def_area_element_inner'
        rootClass = def_area_element_inner
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:mmd-2.0="http://musicbrainz.org/ns/mmd-2.0#"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'def_area_element_inner'
        rootClass = def_area_element_inner
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from models import *\n\n')
        sys.stdout.write('import models as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "alias",
    "alias_list",
    "annotation",
    "annotation_list",
    "area_list",
    "artist",
    "artist_credit",
    "artist_list",
    "artwork",
    "asin",
    "attributeType",
    "attributeType11",
    "attributeType13",
    "attributeType16",
    "attributeType2",
    "attributeType26",
    "attributeType28",
    "attributeType9",
    "attribute_listType",
    "attribute_listType1",
    "attribute_listType10",
    "attribute_listType12",
    "attribute_listType15",
    "attribute_listType25",
    "attribute_listType27",
    "attribute_listType8",
    "back",
    "cancelled",
    "cdstub",
    "cdstub_list",
    "collection",
    "collection_list",
    "coordinates",
    "cover_art_archive",
    "darkened",
    "data_track_list",
    "def_area_element_inner",
    "def_track_data",
    "disc",
    "disc_list",
    "edit_information",
    "editor",
    "editor_list",
    "ended",
    "entity_list",
    "event",
    "event_list",
    "format",
    "freedb_disc",
    "freedb_disc_list",
    "front",
    "gender",
    "instrument",
    "instrument_list",
    "ipi_list",
    "iso_3166_1_code_list",
    "iso_3166_2_code_list",
    "iso_3166_3_code_list",
    "isrc",
    "isrc_list",
    "iswc",
    "iswc_list",
    "label",
    "label_info",
    "label_info_list",
    "label_list",
    "languageType",
    "languageType21",
    "language_list",
    "life_span",
    "life_spanType",
    "life_spanType14",
    "medium",
    "medium_list",
    "metadata",
    "name_credit",
    "offset",
    "offset_list",
    "place",
    "place_list",
    "primary_type",
    "puid",
    "puid_list",
    "rating",
    "recording",
    "recording_list",
    "relation",
    "relation_list",
    "release",
    "release_event",
    "release_event_list",
    "release_group",
    "release_group_list",
    "release_list",
    "secondary_type",
    "secondary_type_list",
    "series",
    "series_list",
    "status",
    "tag",
    "tag_list",
    "target",
    "text_representation",
    "trackType",
    "trackType20",
    "trackType24",
    "trackType7",
    "track_listType",
    "track_listType17",
    "track_listType18",
    "track_listType19",
    "track_listType22",
    "track_listType23",
    "track_listType3",
    "track_listType4",
    "track_listType5",
    "track_listType6",
    "url",
    "url_list",
    "user_tag",
    "user_tag_list",
    "video",
    "work",
    "work_list",
    "year"
]
